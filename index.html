<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="核动力niuniu">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="核动力niuniu">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="核动力niuniu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>核动力niuniu</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">核动力niuniu</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/04/k8s%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/1.Kubernetes%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="核动力niuniu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="核动力niuniu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/04/k8s%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/1.Kubernetes%E4%BB%8B%E7%BB%8D/" class="post-title-link" itemprop="url">1.Kubernetes介绍</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-04 22:20:24" itemprop="dateCreated datePublished" datetime="2022-01-04T22:20:24+08:00">2022-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-05 01:28:13" itemprop="dateModified" datetime="2022-01-05T01:28:13+08:00">2022-01-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Kubernetes详细教程"><a href="#Kubernetes详细教程" class="headerlink" title="Kubernetes详细教程"></a>Kubernetes详细教程</h2><h3 id="Kubernetes介绍"><a href="#Kubernetes介绍" class="headerlink" title="Kubernetes介绍"></a>Kubernetes介绍</h3><h4 id="应用部署方式演变"><a href="#应用部署方式演变" class="headerlink" title="应用部署方式演变"></a>应用部署方式演变</h4><p>在部署应用程序的方式上，主要经历了三个时代：</p>
<ul>
<li><p><strong>传统部署</strong>：互联网早期，会直接将应用程序部署在物理机上</p>
<blockquote>
<p>优点：简单，不需要其它技术的参与</p>
<p>缺点：不能为应用程序定义资源使用边界，很难合理地分配计算资源，而且程序之间容易产生影响</p>
</blockquote>
</li>
<li><p><strong>虚拟化部署</strong>：可以在一台物理机上运行多个虚拟机，每个虚拟机都是独立的一个环境</p>
<blockquote>
<p>优点：程序环境不会相互产生影响，提供了一定程度的安全性</p>
<p>缺点：增加了操作系统，浪费了部分资源</p>
</blockquote>
</li>
<li><p><strong>容器化部署</strong>：与虚拟化类似，但是共享了操作系统</p>
<blockquote>
<p>优点：</p>
<p>可以保证每个容器拥有自己的文件系统、CPU、内存、进程空间等</p>
<p>运行应用程序所需要的资源都被容器包装，并和底层基础架构解耦</p>
<p>容器化的应用程序可以跨云服务商、跨Linux操作系统发行版进行部署</p>
</blockquote>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/k8s/Kubenetes.assets/image-20200505183738289.png" alt="image-20200505183738289"></p>
<p>容器化部署方式给带来很多的便利，但是也会出现一些问题，比如说：</p>
<ul>
<li>一个容器故障停机了，怎么样让另外一个容器立刻启动去替补停机的容器</li>
<li>当并发访问量变大的时候，怎么样做到横向扩展容器数量</li>
</ul>
<p>这些容器管理的问题统称为<strong>容器编排</strong>问题，为了解决这些容器编排问题，就产生了一些容器编排的软件：</p>
<ul>
<li><strong>Swarm</strong>：Docker自己的容器编排工具</li>
<li><strong>Mesos</strong>：Apache的一个资源统一管控的工具，需要和Marathon结合使用</li>
<li><strong>Kubernetes</strong>：Google开源的的容器编排工具</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/k8s/Kubenetes.assets/image-20200524150339551.png" alt="image-20200524150339551"></p>
<h4 id="kubernetes简介"><a href="#kubernetes简介" class="headerlink" title="kubernetes简介"></a>kubernetes简介</h4><p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/k8s/Kubenetes.assets/image-20200406232838722.png" alt="image-20200406232838722"></p>
<p>kubernetes，是一个全新的基于容器技术的分布式架构领先方案，是谷歌严格保密十几年的秘密武器—-Borg系统的一个开源版本，于2014年9月发布第一个版本，2015年7月发布第一个正式版本。</p>
<p>kubernetes的本质是<strong>一组服务器集群</strong>，它可以在集群的每个节点上运行特定的程序，来对节点中的容器进行管理。目的是实现资源管理的自动化，主要提供了如下的主要功能：</p>
<ul>
<li><strong>自我修复</strong>：一旦某一个容器崩溃，能够在1秒中左右迅速启动新的容器</li>
<li><strong>弹性伸缩</strong>：可以根据需要，自动对集群中正在运行的容器数量进行调整</li>
<li><strong>服务发现</strong>：服务可以通过自动发现的形式找到它所依赖的服务</li>
<li><strong>负载均衡</strong>：如果一个服务起动了多个容器，能够自动实现请求的负载均衡</li>
<li><strong>版本回退</strong>：如果发现新发布的程序版本有问题，可以立即回退到原来的版本</li>
<li><strong>存储编排</strong>：可以根据容器自身的需求自动创建存储卷</li>
</ul>
<h4 id="kubernetes组件"><a href="#kubernetes组件" class="headerlink" title="kubernetes组件"></a>kubernetes组件</h4><p>一个kubernetes集群主要是由**控制节点(master)<strong>、</strong>工作节点(node)**构成，每个节点上都会安装不同的组件。</p>
<p><strong>master：集群的控制平面，负责集群的决策 ( 管理 )</strong></p>
<blockquote>
<p><strong>ApiServer</strong> : 资源操作的唯一入口，接收用户输入的命令，提供认证、授权、API注册和发现等机制</p>
<p><strong>Scheduler</strong> : 负责集群资源调度，按照预定的调度策略将Pod调度到相应的node节点上</p>
<p><strong>ControllerManager</strong> : 负责维护集群的状态，比如程序部署安排、故障检测、自动扩展、滚动更新等</p>
<p><strong>Etcd</strong> ：负责存储集群中各种资源对象的信息</p>
</blockquote>
<p><strong>node：集群的数据平面，负责为容器提供运行环境 ( 干活 )</strong></p>
<blockquote>
<p><strong>Kubelet</strong> : 负责维护容器的生命周期，即通过控制docker，来创建、更新、销毁容器</p>
<p><strong>KubeProxy</strong> : 负责提供集群内部的服务发现和负载均衡</p>
<p><strong>Docker</strong> : 负责节点上容器的各种操作</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/k8s/Kubenetes.assets/image-20200406184656917.png" alt="image-20200406184656917"></p>
<p>下面，以部署一个nginx服务来说明kubernetes系统各个组件调用关系：</p>
<ol>
<li><p>首先要明确，一旦kubernetes环境启动之后，master和node都会将自身的信息存储到etcd数据库中</p>
</li>
<li><p>一个nginx服务的安装请求会首先被发送到master节点的apiServer组件</p>
</li>
<li><p>apiServer组件会调用scheduler组件来决定到底应该把这个服务安装到哪个node节点上</p>
<p>在此时，它会从etcd中读取各个node节点的信息，然后按照一定的算法进行选择，并将结果告知apiServer</p>
</li>
<li><p>apiServer调用controller-manager去调度Node节点安装nginx服务</p>
</li>
<li><p>kubelet接收到指令后，会通知docker，然后由docker来启动一个nginx的pod</p>
<p>pod是kubernetes的最小操作单元，容器必须跑在pod中至此，</p>
</li>
<li><p>一个nginx服务就运行了，如果需要访问nginx，就需要通过kube-proxy来对pod产生访问的代理</p>
</li>
</ol>
<p>这样，外界用户就可以访问集群中的nginx服务了</p>
<h4 id="kubernetes概念"><a href="#kubernetes概念" class="headerlink" title="kubernetes概念"></a>kubernetes概念</h4><p><strong>Master</strong>：集群控制节点，每个集群需要至少一个master节点负责集群的管控</p>
<p><strong>Node</strong>：工作负载节点，由master分配容器到这些node工作节点上，然后node节点上的docker负责容器的运行</p>
<p><strong>Pod</strong>：kubernetes的最小控制单元，容器都是运行在pod中的，一个pod中可以有1个或者多个容器</p>
<p><strong>Controller</strong>：控制器，通过它来实现对pod的管理，比如启动pod、停止pod、伸缩pod的数量等等</p>
<p><strong>Service</strong>：pod对外服务的统一入口，下面可以维护者同一类的多个pod</p>
<p><strong>Label</strong>：标签，用于对pod进行分类，同一类pod会拥有相同的标签</p>
<p><strong>NameSpace</strong>：命名空间，用来隔离pod的运行环境</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/04/redis%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/1.NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="核动力niuniu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="核动力niuniu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/04/redis%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/1.NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">1.NoSQL数据库简介</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-04 22:20:24" itemprop="dateCreated datePublished" datetime="2022-01-04T22:20:24+08:00">2022-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-05 20:17:44" itemprop="dateModified" datetime="2022-01-05T20:17:44+08:00">2022-01-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="NoSQL数据库简介"><a href="#NoSQL数据库简介" class="headerlink" title="NoSQL数据库简介"></a>NoSQL数据库简介</h4><h5 id="技术发展"><a href="#技术发展" class="headerlink" title="技术发展"></a>技术发展</h5><p>技术的分类</p>
<p>1、解决功能性的问题：Java、Jsp、RDBMS、Tomcat、HTML、Linux、JDBC、SVN</p>
<p>2、解决扩展性的问题：Struts、Spring、SpringMVC、Hibernate、Mybatis</p>
<p>3、解决性能的问题：NoSQL、Java线程、Hadoop、Nginx、MQ、ElasticSearch</p>
<h6 id="Web1-0时代"><a href="#Web1-0时代" class="headerlink" title="Web1.0时代"></a>Web1.0时代</h6><p>Web1.0的时代，数据访问量很有限，用一夫当关的高性能的单点服务器可以解决大部分问题。</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/image-20211106223642396.png" alt="image-20211106223642396"></p>
<h6 id="Web2-0时代"><a href="#Web2-0时代" class="headerlink" title="Web2.0时代"></a>Web2.0时代</h6><p>随着Web2.0的时代的到来，用户访问量大幅度提升，同时产生了大量的用户数据。加上后来的智能移动设备的普及，所有的互联网平台都面临了巨大的性能挑战。</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/image-20211106175858853.png" alt="image-20211106175858853"> </p>
<h6 id="解决CPU及内存压力"><a href="#解决CPU及内存压力" class="headerlink" title="解决CPU及内存压力"></a>解决CPU及内存压力</h6><p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsnBGq2y.png" alt="img"> </p>
<h6 id="解决IO压力"><a href="#解决IO压力" class="headerlink" title="解决IO压力"></a>解决IO压力</h6><p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpse2F612.png" alt="img"> </p>
<h5 id="NoSQL数据库"><a href="#NoSQL数据库" class="headerlink" title="NoSQL数据库"></a>NoSQL数据库</h5><h6 id="NoSQL数据库概述"><a href="#NoSQL数据库概述" class="headerlink" title="NoSQL数据库概述"></a>NoSQL数据库概述</h6><p>NoSQL(NoSQL = <strong>Not Only SQL</strong>)，意即“不仅仅是SQL”，泛指<strong>非关系型的数据库</strong>。 </p>
<p>NoSQL 不依赖业务逻辑方式存储，而以简单的key-value模式存储。因此大大的增加了数据库的扩展能力。</p>
<ul>
<li><p>不遵循SQL标准。</p>
</li>
<li><p>不支持ACID。</p>
</li>
<li><p>远超于SQL的性能。</p>
</li>
</ul>
<h6 id="NoSQL适用场景"><a href="#NoSQL适用场景" class="headerlink" title="NoSQL适用场景"></a>NoSQL适用场景</h6><ul>
<li><p>对数据高并发的读写</p>
</li>
<li><p>海量数据的读写</p>
</li>
<li><p>对数据高可扩展性的</p>
</li>
</ul>
<h6 id="NoSQL不适用场景"><a href="#NoSQL不适用场景" class="headerlink" title="NoSQL不适用场景"></a>NoSQL不适用场景</h6><ul>
<li><p>需要事务支持</p>
</li>
<li><p>基于sql的结构化查询存储，处理复杂的关系,需要即席查询。</p>
</li>
<li><p>用不着sql的和用了sql也不行的情况，请考虑用NoSql）</p>
</li>
</ul>
<h6 id="Memcache"><a href="#Memcache" class="headerlink" title="Memcache"></a>Memcache</h6><table>
<thead>
<tr>
<th><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsC3MRJ1.png" alt="img" style="zoom:75%;" /></th>
<th>ü 很早出现的NoSql数据库ü 数据都在内存中，一般不持久化ü 支持简单的key-value模式，支持类型单一ü 一般是作为缓存数据库辅助持久化的数据库</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h6 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h6><table>
<thead>
<tr>
<th><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsxexKeP.png" alt="img"></th>
<th>几乎覆盖了Memcached的绝大部分功能数据都在内存中，支持持久化，主要用作备份恢复除了支持简单的key-value模式，还支持多种数据结构的存储，比如 list、set、hash、zset等。一般是作为缓存数据库辅助持久化的数据库</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h6 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h6><table>
<thead>
<tr>
<th><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images//images/wps9uGosP.png" alt="img"></th>
<th>ü 高性能、开源、模式自由(schema  free)的文档型数据库ü 数据都在内存中， 如果内存不足，把不常用的数据保存到硬盘ü 虽然是key-value模式，但是对value（尤其是json）提供了丰富的查询功能ü 支持二进制数据及大型对象ü 可以根据数据的特点替代RDBMS ，成为独立的数据库。或者配合RDBMS，存储特定的数据。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h5 id="行式存储数据库（大数据时代）"><a href="#行式存储数据库（大数据时代）" class="headerlink" title="行式存储数据库（大数据时代）"></a>行式存储数据库（大数据时代）</h5><h6 id="行式数据库"><a href="#行式数据库" class="headerlink" title="行式数据库"></a>行式数据库</h6><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsP36kKk.png" alt="img" style="zoom:75%;" /> 

<h6 id="列式数据库"><a href="#列式数据库" class="headerlink" title="列式数据库"></a>列式数据库</h6><p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsxy3fnz.png" alt="img"> </p>
<p>Hbase</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsQHkGeH.png" alt="img"> </p>
<p>HBase是Hadoop项目中的数据库。它用于需要对大量的数据进行随机、实时的读写操作的场景中。</p>
<p>HBase的目标就是处理数据量非常庞大的表，可以用普通的计算机处理超过10亿行数据，还可处理有数百万列元素的数据表。</p>
<p>Cassandra[kəˈsændrə]</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsaK86nQ.png" alt="img"> </p>
<p>Apache Cassandra是一款免费的开源NoSQL数据库，其设计目的在于管理由大量商用服务器构建起来的庞大集群上的海量数据集(数据量通常达到PB级别)。在众多显著特性当中，Cassandra最为卓越的长处是对写入及读取操作进行规模调整，而且其不强调主集群的设计思路能够以相对直观的方式简化各集群的创建与扩展流程。</p>
<blockquote>
<p>计算机存储单位 计算机存储单位一般用B，KB，MB，GB，TB，EB，ZB，YB，BB来表示，它们之间的关系是：</p>
<p>位 bit (比特)(Binary Digits)：存放一位二进制数，即 0 或 1，最小的存储单位。</p>
<p>字节 byte：8个二进制位为一个字节(B)，最常用的单位。</p>
<p>1KB (Kilobyte 千字节)=1024B，</p>
<p>1MB (Megabyte 兆字节 简称“兆”)=1024KB，</p>
<p>1GB (Gigabyte 吉字节 又称“千兆”)=1024MB，</p>
<p>1TB (Trillionbyte 万亿字节 太字节)=1024GB，其中1024=2^10 ( 2 的10次方)，</p>
<p>1PB（Petabyte 千万亿字节 拍字节）=1024TB，</p>
<p>1EB（Exabyte 百亿亿字节 艾字节）=1024PB，</p>
<p>1ZB (Zettabyte 十万亿亿字节 泽字节)= 1024 EB,</p>
<p>1YB (Jottabyte 一亿亿亿字节 尧字节)= 1024 ZB,</p>
<p>1BB (Brontobyte 一千亿亿亿字节)= 1024 YB.</p>
<p>注：“兆”为百万级数量单位。</p>
</blockquote>
<h5 id="图关系型数据库"><a href="#图关系型数据库" class="headerlink" title="图关系型数据库"></a>图关系型数据库</h5><p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsIkF7t0.png" alt="img"> </p>
<p>主要应用：社会关系，公共交通网络，地图及网络拓谱(n*(n-1)/2)</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsFBhaQX.png" alt="img"> </p>
<h5 id="DB-Engines-数据库排名"><a href="#DB-Engines-数据库排名" class="headerlink" title="DB-Engines 数据库排名"></a>DB-Engines 数据库排名</h5><p><a target="_blank" rel="noopener" href="http://db-engines.com/en/ranking">http://db-engines.com/en/ranking</a></p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsb5t8zl.jpg" alt="img"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/04/redis%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/2.Redis%E6%A6%82%E8%BF%B0%E5%AE%89%E8%A3%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="核动力niuniu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="核动力niuniu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/04/redis%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/2.Redis%E6%A6%82%E8%BF%B0%E5%AE%89%E8%A3%85/" class="post-title-link" itemprop="url">2.Redis概述安装</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-04 22:20:24" itemprop="dateCreated datePublished" datetime="2022-01-04T22:20:24+08:00">2022-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-05 20:22:03" itemprop="dateModified" datetime="2022-01-05T20:22:03+08:00">2022-01-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="Redis概述安装"><a href="#Redis概述安装" class="headerlink" title="Redis概述安装"></a>Redis概述安装</h4><p>Ø Redis是一个开源的key-value存储系统。</p>
<p>Ø 和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。</p>
<p>Ø 这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。</p>
<p>Ø 在此基础上，Redis支持各种不同方式的排序。</p>
<p>Ø 与memcached一样，为了保证效率，数据都是缓存在内存中。</p>
<p>Ø 区别的是Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件。</p>
<p>Ø 并且在此基础上实现了master-slave(主从)同步。</p>
<h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><h6 id="配合关系型数据库做高速缓存"><a href="#配合关系型数据库做高速缓存" class="headerlink" title="配合关系型数据库做高速缓存"></a>配合关系型数据库做高速缓存</h6><p>Ø 高频次，热门访问的数据，降低数据库IO</p>
<p>Ø 分布式架构，做session共享</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsDF5ASI.png" alt="img"> </p>
<h6 id="多样的数据结构存储持久化数据"><a href="#多样的数据结构存储持久化数据" class="headerlink" title="多样的数据结构存储持久化数据"></a>多样的数据结构存储持久化数据</h6><p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsIRdcFW.png" alt="img"> </p>
<h5 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h5><table>
<thead>
<tr>
<th>Redis官方网站</th>
<th>Redis中文官方网站</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="http://redis.io/">http://redis.io</a></td>
<td><a target="_blank" rel="noopener" href="http://redis.cn/">http://redis.cn/</a></td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsmUsI3S.jpg" alt="img"> </p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsCvIJto.jpg" alt="img"> </p>
<h6 id="安装版本"><a href="#安装版本" class="headerlink" title="安装版本"></a>安装版本</h6><p>Ø 6.2.1 for Linux（redis-6.2.1.tar.gz）</p>
<p>Ø 不用考虑在windows环境下对Redis的支持</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpswAbLaj.png" alt="img"> </p>
<h6 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h6><p>准备工作：下载安装最新版的gcc编译器</p>
<h6 id="安装C-语言的编译环境"><a href="#安装C-语言的编译环境" class="headerlink" title="安装C 语言的编译环境"></a>安装C 语言的编译环境</h6><ul>
<li><p>yum install centos-release-scl scl-utils-build</p>
</li>
<li><p>yum install -y devtoolset-8-toolchain</p>
</li>
<li><p>scl enable devtoolset-8 bash</p>
</li>
</ul>
<p>测试 gcc版本 </p>
<ul>
<li>gcc –version</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsfo4FjS.jpg" alt="img"> </p>
<ul>
<li><p>下载redis-6.2.1.tar.gz放/opt目录</p>
</li>
<li><p>解压命令：tar -zxvf redis-6.2.1.tar.gz</p>
</li>
<li><p>解压完成后进入目录：cd redis-6.2.1</p>
</li>
<li><p>在redis-6.2.1目录下再次执行make命令（只是编译好）</p>
</li>
<li><p>如果没有准备好C语言编译环境，make 会报错—Jemalloc/jemalloc.h：没有那个文件</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpstuXSqk.png" alt="img"> </p>
<ul>
<li>解决方案：运行make distclean</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsrmmhyP.png" alt="img"> </p>
<ul>
<li>在redis-6.2.1目录下再次执行make命令（只是编译好）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wps6pB91g.png" alt="img"> </p>
<ul>
<li>跳过make test 继续执行: make install</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpskxuaN8.png" alt="img"> </p>
<h6 id="安装目录：-usr-local-bin"><a href="#安装目录：-usr-local-bin" class="headerlink" title="安装目录：/usr/local/bin"></a>安装目录：/usr/local/bin</h6><p>​    查看默认安装目录：</p>
<p>​    redis-benchmark:性能测试工具，可以在自己本子运行，看看自己本子性能如何</p>
<p>​    redis-check-aof：修复有问题的AOF文件，rdb和aof后面讲</p>
<p>​    redis-check-dump：修复有问题的dump.rdb文件</p>
<p>​    redis-sentinel：Redis集群使用</p>
<p>​    redis-server：Redis服务器启动命令</p>
<p>​    redis-cli：客户端，操作入口</p>
<h6 id="前台启动（不推荐）"><a href="#前台启动（不推荐）" class="headerlink" title="前台启动（不推荐）"></a>前台启动（不推荐）</h6><p>前台启动，命令行窗口不能关闭，否则服务器停止</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsaBCDxO.png" alt="img"> </p>
<h6 id="后台启动（推荐）"><a href="#后台启动（推荐）" class="headerlink" title="后台启动（推荐）"></a>后台启动（推荐）</h6><ol>
<li><p><strong>备份redis.conf</strong></p>
<p>拷贝一份redis.conf到其他目录</p>
<p>cp  /opt/redis-3.2.5/redis.conf  /myredis</p>
</li>
<li><p><strong>后台启动设置daemonize no改成yes</strong></p>
<p>修改redis.conf(128行)文件将里面的daemonize no 改成 yes，让服务在后台启动</p>
</li>
<li><p><strong>Redis启动</strong></p>
<p>redis-server/myredis/redis.conf</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpssZK7Oq.png" alt="img"> </p>
<ol start="4">
<li>用客户端访问：redis-cli</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsWTcXm7.png" alt="img"> </p>
<ol start="5">
<li><p>多个端口可以：redis-cli -p6379</p>
</li>
<li><p>测试验证： ping</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wps7UBIz5.png" alt="img"> </p>
<ol start="7">
<li><p>Redis关闭</p>
<p>单实例关闭：redis-cli shutdown</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsg5dXyO.png" alt="img"> </p>
<p>也可以进入终端后再关闭</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsoRIYTV.png" alt="img"> </p>
<p>多实例关闭，指定端口关闭：redis-cli -p 6379 shutdown</p>
<h6 id="Redis介绍相关知识"><a href="#Redis介绍相关知识" class="headerlink" title="Redis介绍相关知识"></a>Redis介绍相关知识</h6><table>
<thead>
<tr>
<th>端口6379从何而来Alessia  Merz<img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsI3kNRH.png" alt="img"></th>
<th>默认16个数据库，类似数组下标从0开始，初始默认使用0号库使用命令 select  <dbid>来切换数据库。如: select 8 统一密码管理，所有库同样密码。dbsize查看当前数据库的key的数量flushdb清空当前库flushall通杀全部库</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>Redis是单线程+多路IO复用技术</p>
<p>多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）</p>
<p>串行  vs  多线程+锁（memcached） vs  单线程+多路IO复用(Redis)</p>
<p>（与Memcache三点不同: 支持多数据类型，支持持久化，单线程+多路IO复用）  </p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsMOQK0A.png" alt="img"> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/04/redis%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/3.%E5%B8%B8%E7%94%A8%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="核动力niuniu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="核动力niuniu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/04/redis%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/3.%E5%B8%B8%E7%94%A8%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class="post-title-link" itemprop="url">3.常用五大数据类型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-04 22:20:24" itemprop="dateCreated datePublished" datetime="2022-01-04T22:20:24+08:00">2022-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-05 20:26:42" itemprop="dateModified" datetime="2022-01-05T20:26:42+08:00">2022-01-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="常用五大数据类型"><a href="#常用五大数据类型" class="headerlink" title="常用五大数据类型"></a>常用五大数据类型</h4><p>哪里去获得redis常见数据类型操作命令<a target="_blank" rel="noopener" href="http://www.redis.cn/commands.html">http://www.redis.cn/commands.html</a></p>
<h5 id="Redis键-key"><a href="#Redis键-key" class="headerlink" title="Redis键(key)"></a>Redis键(key)</h5><p>**keys *** 查看当前库所有key   (匹配：keys *1)</p>
<p><strong>exists key:</strong>    判断某个key是否存在</p>
<p><strong>type key :</strong>    查看你的key是什么类型</p>
<p><strong>del key :</strong>   删除指定的key数据</p>
<p><strong>unlink key:</strong>  根据value选择非阻塞删除</p>
<p>仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作。</p>
<p><strong>expire key 10:</strong>  10秒钟：为给定的key设置过期时间</p>
<p><strong>ttl key:</strong>     查看还有多少秒过期，-1表示永不过期，-2表示已过期</p>
<p><strong>select:</strong>    命令切换数据库</p>
<p><strong>dbsize:</strong>    查看当前数据库的key的数量</p>
<p><strong>flushdb:</strong>    清空当前库</p>
<p><strong>flushall:</strong>    通杀全部库</p>
<h5 id="Redis字符串-String"><a href="#Redis字符串-String" class="headerlink" title="Redis字符串(String)"></a>Redis字符串(String)</h5><h6 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h6><p>String是Redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。</p>
<p>String类型是二进制安全的。意味着Redis的string可以包含任何数据。比如jpg图片或者序列化的对象。</p>
<p>String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M</p>
<h6 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h6><p>set  <key><value>添加键值对</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wps5ib5ec.jpg" alt="img"> </p>
<p>*NX：当数据库中key不存在时，可以将key-value添加数据库</p>
<p>*XX：当数据库中key存在时，可以将key-value添加数据库，与NX参数互斥</p>
<p>*EX：key的超时秒数</p>
<p>*PX：key的超时毫秒数，与EX互斥</p>
<p>get  <key>查询对应键值</p>
<p>append  <key><value>将给定的<value> 追加到原值的末尾</p>
<p>strlen  <key>获得值的长度</p>
<p>setnx  <key><value>只有在 key 不存在时   设置 key 的值</p>
<p>incr  <key></p>
<p>将 key 中储存的数字值增1</p>
<p>只能对数字值操作，如果为空，新增值为1</p>
<p>decr  <key></p>
<p>将 key 中储存的数字值减1</p>
<p>只能对数字值操作，如果为空，新增值为-1</p>
<p>incrby / decrby  <key>&lt;步长&gt;将 key 中储存的数字值增减。自定义步长。</p>
<p>原子性<img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpszouWWt.png" alt="img"> 所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。（1）在单线程中， 能够在单条指令中完成的操作都可以认为是”原子操作”，因为中断只能发生于指令之间。（2）在多线程中，不能被其它进程（线程）打断的操作就叫原子操作。Redis单命令的原子性主要得益于Redis的单线程。案例：java中的i++是否是原子操作？不是i=0;两个线程分别对i进行++100次,值是多少？ 2~200i=0i++i=99 i=1 i++i=2i=0  i++ i=1 i++ i=100 </p>
<blockquote>
<p><strong>mset</strong>  <key1><value1><key2><value2>  ….. </p>
<p>同时设置一个或多个 key-value对  </p>
<p><strong>mget</strong>  <key1><key2><key3> …..</p>
<p>同时获取一个或多个 value  </p>
<p><strong>msetnx</strong> <key1><value1><key2><value2>  ….. </p>
<p>同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。</p>
<p>原子性，有一个失败则都失败</p>
<p><strong>getrange</strong>  <key>&lt;起始位置&gt;&lt;结束位置&gt;</p>
<p>获得值的范围，类似java中的substring，前包，后包</p>
<p><strong>setrange</strong>  <key>&lt;起始位置&gt;<value></p>
<p>用 <value>  覆写<key>所储存的字符串值，从&lt;起始位置&gt;开始(索引从0开始)。</p>
<p><strong>setex</strong>  <key>&lt;过期时间&gt;<value></p>
<p>设置键值的同时，设置过期时间，单位秒。</p>
<p><strong>getset</strong> <key><value></p>
<p>以新换旧，设置了新值同时获得旧值。</p>
</blockquote>
<h6 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h6><p>String的数据结构为简单动态字符串(Simple Dynamic String,缩写SDS)。是可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配.</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsjwPzAS.jpg" alt="img"> </p>
<p>如图中所示，内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度len。当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。需要注意的是字符串最大长度为512M。</p>
<h5 id="Redis列表-List"><a href="#Redis列表-List" class="headerlink" title="Redis列表(List)"></a>Redis列表(List)</h5><h6 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h6><p>单键多值</p>
<p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p>
<p>它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsl87VGr.png" alt="img"> </p>
<h6 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h6><blockquote>
<p><strong>lpush/rpush</strong>  <key><value1><value2><value3> …. 从左边/右边插入一个或多个值。</p>
<p><strong>lpop/rpop</strong>  <key>从左边/右边吐出一个值。值在键在，值光键亡。</p>
<p><strong>rpoplpush</strong>  <key1><key2>从<key1>列表右边吐出一个值，插到<key2>列表左边。</p>
<p><strong>lrange</strong> <key><start><stop></p>
<p>按照索引下标获得元素(从左到右)</p>
<p><strong>lrange mylist 0 -1</strong>  0左边第一个，-1右边第一个，（0-1表示获取所有）</p>
<p><strong>lindex</strong> <key><index>按照索引下标获得元素(从左到右)</p>
<p><strong>llen</strong> <key>获得列表长度 </p>
<p><strong>linsert</strong> <key>  before <value><newvalue>在<value>的后面插入<newvalue>插入值</p>
<p><strong>lrem</strong> <key><n><value>从左边删除n个value(从左到右)</p>
<p><strong>lset</strong><key><index><value>将列表key下标为index的值替换成value</p>
</blockquote>
<h6 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h6><p>​    List的数据结构为快速链表quickList。</p>
<p>​    首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表。</p>
<p>它将所有的元素紧挨着一起存储，分配的是一块连续的内存。</p>
<p>当数据量比较多的时候才会改成quicklist。</p>
<p>因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsOLgubH.jpg" alt="img"> </p>
<p>Redis将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p>
<h5 id="Redis集合-Set"><a href="#Redis集合-Set" class="headerlink" title="Redis集合(Set)"></a>Redis集合(Set)</h5><h6 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h6><p>Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。</p>
<p>Redis的Set是string类型的无序集合。它底层其实是一个value为null的hash表，所以添加，删除，查找的复杂度都是O(1)。</p>
<p>一个算法，随着数据的增加，执行时间的长短，如果是O(1)，数据增加，查找数据的时间不变</p>
<h6 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h6><p>sadd <key><value1><value2> ….. </p>
<p>将一个或多个 member 元素加入到集合 key 中，已经存在的 member 元素将被忽略</p>
<p>smembers <key>取出该集合的所有值。</p>
<p>sismember <key><value>判断集合<key>是否为含有该<value>值，有1，没有0</p>
<p>scard<key>返回该集合的元素个数。</p>
<p>srem <key><value1><value2> …. 删除集合中的某个元素。</p>
<p>spop <key>随机从该集合中吐出一个值。</p>
<p>srandmember <key><n>随机从该集合中取出n个值。不会从集合中删除 。</p>
<p>smove <source><destination>value把集合中一个值从一个集合移动到另一个集合</p>
<p>sinter <key1><key2>返回两个集合的交集元素。</p>
<p>sunion <key1><key2>返回两个集合的并集元素。</p>
<p>sdiff <key1><key2>返回两个集合的差集元素(key1中的，不包含key2中的)</p>
<h6 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h6><p>Set数据结构是dict字典，字典是用哈希表实现的。</p>
<p>Java中HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。Redis的set结构也是一样，它的内部也使用hash结构，所有的value都指向同一个内部值。</p>
<h5 id="Redis哈希-Hash"><a href="#Redis哈希-Hash" class="headerlink" title="Redis哈希(Hash)"></a>Redis哈希(Hash)</h5><h6 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h6><p>Redis hash 是一个键值对集合。</p>
<p>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p>
<p>类似Java里面的Map&lt;String,Object&gt;</p>
<p>用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key/value结构来存储</p>
<p>主要有以下2种存储方式：</p>
<table>
<thead>
<tr>
<th><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsiR7jlN.png" alt="img"> 每次修改用户的某个属性需要，先反序列化改好后再序列化回去。开销较大。</th>
<th><img src="images/wps7ahE9x.png" alt="img"> 用户ID数据冗余</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsrnOp1m.png" alt="img"> 通过 key(用户ID) + field(属性标签) 就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题</p>
<h6 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a>常用命令</h6><blockquote>
<p><strong>hset</strong> <key><field><value>给<key>集合中的  <field>键赋值<value></p>
<p><strong>hget</strong> <key1><field>从<key1>集合<field>取出 value </p>
<p><strong>hmset</strong> <key1><field1><value1><field2><value2>… 批量设置hash的值</p>
<p><strong>hexists</strong><key1><field>查看哈希表 key 中，给定域 field 是否存在。 </p>
<p><strong>hkeys</strong> <key>列出该hash集合的所有field</p>
<p><strong>hvals</strong> <key>列出该hash集合的所有value</p>
<p><strong>hincrby</strong> <key><field><increment>为哈希表 key 中的域 field 的值加上增量 1  -1</p>
<p><strong>hsetnx</strong> <key><field><value>将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在 .</p>
</blockquote>
<h6 id="数据结构-3"><a href="#数据结构-3" class="headerlink" title="数据结构"></a>数据结构</h6><p>Hash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable。</p>
<h5 id="Redis有序集合Zset-sorted-set"><a href="#Redis有序集合Zset-sorted-set" class="headerlink" title="Redis有序集合Zset(sorted set)"></a>Redis有序集合Zset(sorted set)</h5><h6 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h6><p>Redis有序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集合。</p>
<p>不同之处是有序集合的每个成员都关联了一个评分（score）,这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复了 。</p>
<p>因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。</p>
<p>访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。</p>
<h6 id="常用命令-4"><a href="#常用命令-4" class="headerlink" title="常用命令"></a>常用命令</h6><blockquote>
<p>zadd  <key><score1><value1><score2><value2>…</p>
<p>将一个或多个 member 元素及其 score 值加入到有序集 key 当中。</p>
<p>zrange <key><start><stop>  [WITHSCORES]  </p>
<p>返回有序集 key 中，下标在<start><stop>之间的元素</p>
<p>带WITHSCORES，可以让分数一起和值返回到结果集。</p>
<p>zrangebyscore key minmax [withscores] [limit offset count]</p>
<p>返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。 </p>
<p>zrevrangebyscore key maxmin [withscores] [limit offset count]        </p>
<p>同上，改为从大到小排列。 </p>
<p>zincrby <key><increment><value>    为元素的score加上增量</p>
<p>zrem  <key><value>删除该集合下，指定值的元素 </p>
<p>zcount <key><min><max>统计该集合，分数区间内的元素个数 </p>
<p>zrank <key><value>返回该值在集合中的排名，从0开始。</p>
<p>案例：如何利用zset实现一个文章访问量的排行榜？</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wps2DNHKu.png" alt="img"> </p>
<h6 id="数据结构-4"><a href="#数据结构-4" class="headerlink" title="数据结构"></a>数据结构</h6><p>SortedSet(zset)是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构Map&lt;String, Double&gt;，可以给每一个元素value赋予一个权重score，另一方面它又类似于TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。</p>
<p>zset底层使用了两个数据结构</p>
<p>（1）hash，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。</p>
<p>（2）跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。</p>
<h6 id="跳跃表（跳表）"><a href="#跳跃表（跳表）" class="headerlink" title="跳跃表（跳表）"></a>跳跃表（跳表）</h6><p>1、简介</p>
<p>​    有序集合在生活中比较常见，例如根据成绩对学生排名，根据得分对玩家排名等。对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。Redis采用的是跳跃表。跳跃表效率堪比红黑树，实现远比红黑树简单。</p>
<p>2、实例</p>
<p>​    对比有序链表和跳跃表，从链表中查询出51</p>
<p>（1） 有序链表</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsMwAaVC.jpg" alt="img"> </p>
<p>要查找值为51的元素，需要从第一个元素开始依次查找、比较才能找到。共需要6次比较。</p>
<p>（2） 跳跃表</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wps7rEkBd.jpg" alt="img"> </p>
<p>从第2层开始，1节点比51节点小，向后比较。</p>
<p>21节点比51节点小，继续向后比较，后面就是NULL了，所以从21节点向下到第1层</p>
<p>在第1层，41节点比51节点小，继续向后，61节点比51节点大，所以从41向下</p>
<p>在第0层，51节点为要查找的节点，节点被找到，共查找4次。</p>
<p>从此可以看出跳跃表比有序链表效率要高</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/04/redis%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/4.Redis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="核动力niuniu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="核动力niuniu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/04/redis%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/4.Redis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D/" class="post-title-link" itemprop="url">4.Redis配置文件介绍</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-04 22:20:24" itemprop="dateCreated datePublished" datetime="2022-01-04T22:20:24+08:00">2022-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-05 20:25:41" itemprop="dateModified" datetime="2022-01-05T20:25:41+08:00">2022-01-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="Redis配置文件介绍"><a href="#Redis配置文件介绍" class="headerlink" title="Redis配置文件介绍"></a>Redis配置文件介绍</h4><p>自定义目录：/myredis/redis.conf</p>
<h5 id="Units单位"><a href="#Units单位" class="headerlink" title="Units单位"></a>Units单位</h5><p>配置大小单位,开头定义了一些基本的度量单位，只支持bytes，不支持bit</p>
<p>大小写不敏感</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpskauzTC.png" alt="img"> </p>
<h5 id="INCLUDES包含"><a href="#INCLUDES包含" class="headerlink" title="INCLUDES包含"></a>INCLUDES包含</h5><p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wps1A11xr.png" alt="img"> </p>
<p>类似jsp中的include，多实例的情况可以把公用的配置文件提取出来</p>
<h5 id="网络相关配置"><a href="#网络相关配置" class="headerlink" title="网络相关配置"></a>网络相关配置</h5><h6 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h6><p>默认情况bind=127.0.0.1只能接受本机的访问请求</p>
<p>不写的情况下，无限制接受任何ip地址的访问</p>
<p>生产环境肯定要写你应用服务器的地址；服务器是需要远程访问的，所以需要将其注释掉</p>
<p>如果开启了protected-mode，那么在没有设定bind ip且没有设密码的情况下，Redis只允许接受本机的响应</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsL4G8Lx.png" alt="img"> </p>
<p>保存配置，停止服务，重启启动查看进程，不再是本机访问了。</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsSjGu58.png" alt="img"> </p>
<h6 id="protected-mode"><a href="#protected-mode" class="headerlink" title="protected-mode"></a>protected-mode</h6><p>将本机访问保护模式设置no</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsVgzx6B.png" alt="img"> </p>
<h6 id="Port"><a href="#Port" class="headerlink" title="Port"></a>Port</h6><p>端口号，默认 6379</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsyAAKA9.png" alt="img"> </p>
<h6 id="tcp-backlog"><a href="#tcp-backlog" class="headerlink" title="tcp-backlog"></a>tcp-backlog</h6><p>设置tcp的backlog，backlog其实是一个连接队列，backlog队列总和=未完成三次握手队列 + 已经完成三次握手队列。</p>
<p>在高并发环境下你需要一个高backlog值来避免慢客户端连接问题。</p>
<p>注意Linux内核会将这个值减小到/proc/sys/net/core/somaxconn的值（128），所以需要确认增大/proc/sys/net/core/somaxconn和/proc/sys/net/ipv4/tcp_max_syn_backlog（128）两个值来达到想要的效果</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wps4N45mL.png" alt="img"> </p>
<h6 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h6><p>一个空闲的客户端维持多少秒会关闭，0表示关闭该功能。即永不关闭。</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wps0HFl14.png" alt="img"> </p>
<h6 id="tcp-keepalive"><a href="#tcp-keepalive" class="headerlink" title="tcp-keepalive"></a>tcp-keepalive</h6><p>对访问客户端的一种心跳检测，每个n秒检测一次。</p>
<p>单位为秒，如果设置为0，则不会进行Keepalive检测，建议设置成60 </p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsomc1nX.png" alt="img"> </p>
<h5 id="GENERAL通用"><a href="#GENERAL通用" class="headerlink" title="GENERAL通用"></a>GENERAL通用</h5><h6 id="daemonize"><a href="#daemonize" class="headerlink" title="daemonize"></a>daemonize</h6><p>是否为后台进程，设置为yes</p>
<p>守护进程，后台启动</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpszywqZp.png" alt="img"> </p>
<h6 id="pidfile"><a href="#pidfile" class="headerlink" title="pidfile"></a>pidfile</h6><p>存放pid文件的位置，每个实例会产生一个不同的pid文件</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpszbcKRZ.png" alt="img"> </p>
<h6 id="loglevel"><a href="#loglevel" class="headerlink" title="loglevel"></a>loglevel</h6><p>指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为notice</p>
<p>四个级别根据使用阶段来选择，生产环境选择notice 或者warning</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsvf4219.png" alt="img"> </p>
<h6 id="logfile"><a href="#logfile" class="headerlink" title="logfile"></a>logfile</h6><p>日志文件名称</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpstpgjdo.png" alt="img"> </p>
<h6 id="databases-16"><a href="#databases-16" class="headerlink" title="databases 16"></a>databases 16</h6><p>设定库的数量 默认16，默认数据库为0，可以使用SELECT <dbid>命令在连接上指定数据库id</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpse24tkp.png" alt="img"> </p>
<h5 id="SECURITY安全"><a href="#SECURITY安全" class="headerlink" title="SECURITY安全"></a>SECURITY安全</h5><h6 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h6><p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsfHOK4h.png" alt="img"> </p>
<p>访问密码的查看、设置和取消</p>
<p>在命令中设置密码，只是临时的。重启redis服务器，密码就还原了。</p>
<p>永久设置，需要再配置文件中进行设置。</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wps1feu1f.png" alt="img"> </p>
<h5 id="LIMITS限制"><a href="#LIMITS限制" class="headerlink" title="LIMITS限制"></a>LIMITS限制</h5><h6 id="maxclients"><a href="#maxclients" class="headerlink" title="maxclients"></a>maxclients</h6><p>Ø 设置redis同时可以与多少个客户端进行连接。</p>
<p>Ø 默认情况下为10000个客户端。</p>
<p>Ø 如果达到了此限制，redis则会拒绝新的连接请求，并且向这些连接请求方发出“max number of clients reached”以作回应。</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsEl2jUr.png" alt="img"> </p>
<h6 id="maxmemory"><a href="#maxmemory" class="headerlink" title="maxmemory"></a>maxmemory</h6><p>Ø 建议必须设置，否则，将内存占满，造成服务器宕机</p>
<p>Ø 设置redis可以使用的内存量。一旦到达内存使用上限，redis将会试图移除内部数据，移除规则可以通过maxmemory-policy来指定。</p>
<p>Ø 如果redis无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”，那么redis则会针对那些需要申请内存的指令返回错误信息，比如SET、LPUSH等。</p>
<p>Ø 但是对于无内存申请的指令，仍然会正常响应，比如GET等。如果你的redis是主redis（说明你的redis有从redis），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，才不用考虑这个因素。</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wps0taWyw.png" alt="img"> </p>
<h6 id="maxmemory-policy"><a href="#maxmemory-policy" class="headerlink" title="maxmemory-policy"></a>maxmemory-policy</h6><p>Ø volatile-lru：使用LRU算法移除key，只对设置了过期时间的键；（最近最少使用）</p>
<p>Ø allkeys-lru：在所有集合key中，使用LRU算法移除key</p>
<p>Ø volatile-random：在过期集合中移除随机的key，只对设置了过期时间的键</p>
<p>Ø allkeys-random：在所有集合key中，移除随机的key</p>
<p>Ø volatile-ttl：移除那些TTL值最小的key，即那些最近要过期的key</p>
<p>Ø noeviction：不进行移除。针对写操作，只是返回错误信息</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsDEojw6.png" alt="img"> </p>
<h6 id="maxmemory-samples"><a href="#maxmemory-samples" class="headerlink" title="maxmemory-samples"></a>maxmemory-samples</h6><p>Ø 设置样本数量，LRU算法和最小TTL算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小，redis默认会检查这么多个key并选择其中LRU的那个。</p>
<p>Ø 一般设置3到7的数字，数值越小样本越不准确，但性能消耗越小。</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsi14yIt.png" alt="img"> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/04/redis%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/5.Redis%E7%9A%84%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="核动力niuniu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="核动力niuniu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/04/redis%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/5.Redis%E7%9A%84%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85/" class="post-title-link" itemprop="url">5.Redis的发布和订阅</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-04 22:20:24" itemprop="dateCreated datePublished" datetime="2022-01-04T22:20:24+08:00">2022-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-05 20:27:57" itemprop="dateModified" datetime="2022-01-05T20:27:57+08:00">2022-01-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="Redis的发布和订阅"><a href="#Redis的发布和订阅" class="headerlink" title="Redis的发布和订阅"></a>Redis的发布和订阅</h4><h5 id="什么是发布和订阅"><a href="#什么是发布和订阅" class="headerlink" title="什么是发布和订阅"></a>什么是发布和订阅</h5><p>Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。</p>
<p>Redis 客户端可以订阅任意数量的频道。</p>
<h5 id="Redis的发布和订阅-1"><a href="#Redis的发布和订阅-1" class="headerlink" title="Redis的发布和订阅"></a>Redis的发布和订阅</h5><p>1、客户端可以订阅频道如下图</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpseH2qkE.jpg" alt="img"> </p>
<p>2、当给这个频道发布消息后，消息就会发送给订阅的客户端</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsTzPZ3f.jpg" alt="img"> </p>
<h5 id="发布订阅命令行实现"><a href="#发布订阅命令行实现" class="headerlink" title="发布订阅命令行实现"></a>发布订阅命令行实现</h5><p>1、 打开一个客户端订阅channel1</p>
<p>SUBSCRIBE channel1</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsasL1s1.jpg" alt="img"> </p>
<p>2、打开另一个客户端，给channel1发布消息hello</p>
<p>publish channel1 hello</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpslLhjCY.jpg" alt="img"> </p>
<p>返回的1是订阅者数量</p>
<p>3、打开第一个客户端可以看到发送的消息</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsqTEudf.jpg" alt="img"> </p>
<p>注：发布的消息没有持久化，如果在订阅的客户端收不到hello，只能收到订阅后发布的消息</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/04/redis%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/6.Redis%E6%96%B0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="核动力niuniu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="核动力niuniu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/04/redis%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/6.Redis%E6%96%B0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class="post-title-link" itemprop="url">6.Redis新数据类型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-04 22:20:24" itemprop="dateCreated datePublished" datetime="2022-01-04T22:20:24+08:00">2022-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-05 20:29:04" itemprop="dateModified" datetime="2022-01-05T20:29:04+08:00">2022-01-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="Redis新数据类型"><a href="#Redis新数据类型" class="headerlink" title="Redis新数据类型"></a>Redis新数据类型</h4><h5 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h5><h6 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h6><p>现代计算机用二进制（位） 作为信息的基础单位， 1个字节等于8位， 例如“abc”字符串是由3个字节组成， 但实际在计算机存储时将其用二进制表示， “abc”分别对应的ASCII码分别是97、 98、 99， 对应的二进制分别是01100001、 01100010和01100011，如下图</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsZXmUpQ.jpg" alt="img"> </p>
<p>合理地使用操作位能够有效地提高内存使用率和开发效率。</p>
<p>​    Redis提供了Bitmaps这个“数据类型”可以实现对位的操作：</p>
<p>（1） Bitmaps本身不是一种数据类型， 实际上它就是字符串（key-value） ， 但是它可以对字符串的位进行操作。</p>
<p>（2） Bitmaps单独提供了一套命令， 所以在Redis中使用Bitmaps和使用字符串的方法不太相同。 可以把Bitmaps想象成一个以位为单位的数组， 数组的每个单元只能存储0和1， 数组的下标在Bitmaps中叫做偏移量。</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsdi4EnQ.jpg" alt="img"> </p>
<h6 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h6><p>1、setbit</p>
<p>（1）格式</p>
<p>setbit<key><offset><value>设置Bitmaps中某个偏移量的值（0或1）</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsuME1NF.jpg" alt="img"> </p>
<p>*offset:偏移量从0开始</p>
<p>（2）实例</p>
<p>每个独立用户是否访问过网站存放在Bitmaps中， 将访问的用户记做1， 没有访问的用户记做0， 用偏移量作为用户的id。</p>
<p>设置键的第offset个位的值（从0算起） ， 假设现在有20个用户，userid=1， 6， 11， 15， 19的用户对网站进行了访问， 那么当前Bitmaps初始化结果如图</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsByYnuo.jpg" alt="img"> </p>
<p>unique:users:20201106代表2020-11-06这天的独立访问用户的Bitmaps</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpscoD2Vh.jpg" alt="img"> </p>
<p>注：</p>
<p>很多应用的用户id以一个指定数字（例如10000） 开头， 直接将用户id和Bitmaps的偏移量对应势必会造成一定的浪费， 通常的做法是每次做setbit操作时将用户id减去这个指定数字。</p>
<p>在第一次初始化Bitmaps时， 假如偏移量非常大， 那么整个初始化过程执行会比较慢， 可能会造成Redis的阻塞。</p>
<p>2、getbit</p>
<p>（1）格式</p>
<p>getbit<key><offset>获取Bitmaps中某个偏移量的值</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsneUclX.jpg" alt="img"> </p>
<p>获取键的第offset位的值（从0开始算）</p>
<p>（2）实例</p>
<p>获取id=8的用户是否在2020-11-06这天访问过， 返回0说明没有访问过：</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsw4n3PU.jpg" alt="img"> </p>
<p>注：因为100根本不存在，所以也是返回0</p>
<p>3、bitcount</p>
<p>统计字符串被设置为1的bit数。一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。start 和 end 参数的设置，都可以使用负数值：比如 -1 表示最后一个位，而 -2 表示倒数第二个位，start、end 是指bit组的字节的下标数，二者皆包含。</p>
<p>（1）格式</p>
<p>bitcount<key>[start end] 统计字符串从start字节到end字节比特值为1的数量</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsvXGvCe.jpg" alt="img"> </p>
<p>（2）实例</p>
<p>计算2022-11-06这天的独立访问用户数量</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wps89FZyg.jpg" alt="img"> </p>
<p>start和end代表起始和结束字节数， 下面操作计算用户id在第1个字节到第3个字节之间的独立访问用户数， 对应的用户id是11， 15， 19。</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsWXoBdu.jpg" alt="img"> </p>
<p>举例： K1 【01000001 01000000  00000000 00100001】，对应【0，1，2，3】</p>
<p>bitcount K1 1 2  ： 统计下标1、2字节组中bit=1的个数，即01000000  00000000</p>
<p>–》bitcount K1 1 2 　　–》1</p>
<p>bitcount K1 1 3  ： 统计下标1、2字节组中bit=1的个数，即01000000  00000000 00100001</p>
<p>–》bitcount K1 1 3　　–》3</p>
<p>bitcount K1 0 -2  ： 统计下标0到下标倒数第2，字节组中bit=1的个数，即01000001  01000000  00000000</p>
<p>–》bitcount K1 0 -2　　–》3</p>
<p> 注意：redis的setbit设置或清除的是bit位置，而bitcount计算的是byte位置。</p>
<p>4、bitop</p>
<p>(1)格式</p>
<p>bitop and(or/not/xor) <destkey> [key…]</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wps6Owby0.jpg" alt="img"> </p>
<p>bitop是一个复合操作， 它可以做多个Bitmaps的and（交集） 、 or（并集） 、 not（非） 、 xor（异或） 操作并将结果保存在destkey中。</p>
<p>(2)实例</p>
<p>2020-11-04 日访问网站的userid=1,2,5,9。</p>
<p>setbit unique:users:20201104 1 1</p>
<p>setbit unique:users:20201104 2 1</p>
<p>setbit unique:users:20201104 5 1</p>
<p>setbit unique:users:20201104 9 1</p>
<p>2020-11-03 日访问网站的userid=0,1,4,9。</p>
<p>setbit unique:users:20201103 0 1</p>
<p>setbit unique:users:20201103 1 1</p>
<p>setbit unique:users:20201103 4 1</p>
<p>setbit unique:users:20201103 9 1</p>
<p>计算出两天都访问过网站的用户数量</p>
<p>bitop and unique:users:and:20201104_03</p>
<p> unique:users:20201103unique:users:20201104</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsefMJAU.jpg" alt="img"> </p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsz2jrji.jpg" alt="img"> </p>
<p>计算出任意一天都访问过网站的用户数量（例如月活跃就是类似这种） ， 可以使用or求并集</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsw3pgAP.jpg" alt="img"> </p>
<h6 id="Bitmaps与set对比"><a href="#Bitmaps与set对比" class="headerlink" title="Bitmaps与set对比"></a>Bitmaps与set对比</h6><p>假设网站有1亿用户， 每天独立访问的用户有5千万， 如果每天用集合类型和Bitmaps分别存储活跃用户可以得到表</p>
<table>
<thead>
<tr>
<th>set和Bitmaps存储一天活跃用户对比</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>数据类型</td>
<td>每个用户id占用空间</td>
<td>需要存储的用户量</td>
<td>全部内存量</td>
</tr>
<tr>
<td>集合类型</td>
<td>64位</td>
<td>50000000</td>
<td>64位*50000000 = 400MB</td>
</tr>
<tr>
<td>Bitmaps</td>
<td>1位</td>
<td>100000000</td>
<td>1位*100000000 = 12.5MB</td>
</tr>
</tbody></table>
<p>很明显， 这种情况下使用Bitmaps能节省很多的内存空间， 尤其是随着时间推移节省的内存还是非常可观的</p>
<table>
<thead>
<tr>
<th>set和Bitmaps存储独立用户空间对比</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>数据类型</td>
<td>一天</td>
<td>一个月</td>
<td>一年</td>
</tr>
<tr>
<td>集合类型</td>
<td>400MB</td>
<td>12GB</td>
<td>144GB</td>
</tr>
<tr>
<td>Bitmaps</td>
<td>12.5MB</td>
<td>375MB</td>
<td>4.5GB</td>
</tr>
</tbody></table>
<p>但Bitmaps并不是万金油， 假如该网站每天的独立访问用户很少， 例如只有10万（大量的僵尸用户） ， 那么两者的对比如下表所示， 很显然， 这时候使用Bitmaps就不太合适了， 因为基本上大部分位都是0。</p>
<table>
<thead>
<tr>
<th>set和Bitmaps存储一天活跃用户对比（独立用户比较少）</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>数据类型</td>
<td>每个userid占用空间</td>
<td>需要存储的用户量</td>
<td>全部内存量</td>
</tr>
<tr>
<td>集合类型</td>
<td>64位</td>
<td>100000</td>
<td>64位*100000 = 800KB</td>
</tr>
<tr>
<td>Bitmaps</td>
<td>1位</td>
<td>100000000</td>
<td>1位*100000000 = 12.5MB</td>
</tr>
</tbody></table>
<h5 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h5><h6 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h6><p>在工作当中，我们经常会遇到与统计相关的功能需求，比如统计网站PV（PageView页面访问量）,可以使用Redis的incr、incrby轻松实现。</p>
<p>但像UV（UniqueVisitor，独立访客）、独立IP数、搜索记录数等需要去重和计数的问题如何解决？这种求集合中不重复元素个数的问题称为基数问题。</p>
<p>解决基数问题有很多种方案：</p>
<p>（1）数据存储在MySQL表中，使用distinct count计算不重复个数</p>
<p>（2）使用Redis提供的hash、set、bitmaps等数据结构来处理</p>
<p>以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。</p>
<p>能否能够降低一定的精度来平衡存储空间？Redis推出了HyperLogLog</p>
<p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p>
<p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p>
<p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p>
<p>什么是基数?</p>
<p>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</p>
<h6 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h6><p>1、pfadd </p>
<p>（1）格式</p>
<p>pfadd <key>&lt; element&gt; [element …]  添加指定元素到 HyperLogLog 中</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsyBtJVv.jpg" alt="img"> </p>
<p>（2）实例</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsIvFA0m.jpg" alt="img"> </p>
<p>​    将所有元素添加到指定HyperLogLog数据结构中。如果执行命令后HLL估计的近似基数发生变化，则返回1，否则返回0。</p>
<p>2、pfcount</p>
<p>（1）格式</p>
<p>pfcount<key> [key …] 计算HLL的近似基数，可以计算多个HLL，比如用HLL存储每天的UV，计算一周的UV可以使用7天的UV合并计算即可</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsZmcy1b.jpg" alt="img"> </p>
<p>（2）实例</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpskhJXL9.jpg" alt="img"> </p>
<p>3、pfmerge</p>
<p>（1）格式</p>
<p>pfmerge<destkey><sourcekey> [sourcekey …]  将一个或多个HLL合并后的结果存储在另一个HLL中，比如每月活跃用户可以使用每天的活跃用户来合并计算可得</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsR1ThFm.jpg" alt="img"> </p>
<p>（2）实例</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsMYyOee.jpg" alt="img"> </p>
<h5 id="Geospatial"><a href="#Geospatial" class="headerlink" title="Geospatial"></a>Geospatial</h5><h6 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h6><p>Redis 3.2 中增加了对GEO类型的支持。GEO，Geographic，地理信息的缩写。该类型，就是元素的2维坐标，在地图上就是经纬度。redis基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作。</p>
<h6 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h6><p>1、geoadd</p>
<p>（1）格式</p>
<p>geoadd<key>&lt; longitude&gt;<latitude><member> [longitude latitude member…]  添加地理位置（经度，纬度，名称）</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsMxAmPE.jpg" alt="img"> </p>
<p>（2）实例</p>
<p>geoadd china:city 121.47 31.23 shanghai</p>
<p>geoadd china:city 106.50 29.53 chongqing 114.05 22.52 shenzhen 116.38 39.90 beijing</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsqJNuHc.jpg" alt="img"> </p>
<p>两极无法直接添加，一般会下载城市数据，直接通过 Java 程序一次性导入。</p>
<p>有效的经度从 -180 度到 180 度。有效的纬度从 -85.05112878 度到 85.05112878 度。</p>
<p>当坐标位置超出指定范围时，该命令将会返回一个错误。</p>
<p>已经添加的数据，是无法再次往里面添加的。</p>
<p>2、geopos  </p>
<p>（1）格式</p>
<p>geopos  <key><member> [member…]  获得指定地区的坐标值</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsJGSoaK.jpg" alt="img"> </p>
<p>（2）实例</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpspgtNar.jpg" alt="img"> </p>
<p>3、geodist</p>
<p>（1）格式</p>
<p>geodist<key><member1><member2>  [m|km|ft|mi ]  获取两个位置之间的直线距离</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wps6LOrq5.jpg" alt="img"> </p>
<p>（2）实例</p>
<p>获取两个位置之间的直线距离</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wps8pn15k.jpg" alt="img"> </p>
<p>单位：</p>
<p>m 表示单位为米[默认值]。</p>
<p>km 表示单位为千米。</p>
<p>mi 表示单位为英里。</p>
<p>ft 表示单位为英尺。</p>
<p>如果用户没有显式地指定单位参数， 那么 GEODIST 默认使用米作为单位</p>
<p>4、georadius</p>
<p>（1）格式</p>
<p>georadius<key>&lt; longitude&gt;<latitude>radius m|km|ft|mi  以给定的经纬度为中心，找出某一半径内的元素</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsTYfBml.jpg" alt="img"> </p>
<p>经度 纬度 距离 单位</p>
<p>（2）实例</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsYPkw7s.jpg" alt="img"> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/04/redis%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/8.Redis%E4%B8%8ESpring%20Boot%E6%95%B4%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="核动力niuniu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="核动力niuniu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/04/redis%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/8.Redis%E4%B8%8ESpring%20Boot%E6%95%B4%E5%90%88/" class="post-title-link" itemprop="url">8.Redis与Spring Boot整合</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-04 22:20:24" itemprop="dateCreated datePublished" datetime="2022-01-04T22:20:24+08:00">2022-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-05 20:30:12" itemprop="dateModified" datetime="2022-01-05T20:30:12+08:00">2022-01-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="Redis与Spring-Boot整合"><a href="#Redis与Spring-Boot整合" class="headerlink" title="Redis与Spring Boot整合"></a>Redis与Spring Boot整合</h4><p>Spring Boot整合Redis非常简单，只需要按如下步骤整合即可</p>
<h5 id="整合步骤"><a href="#整合步骤" class="headerlink" title="整合步骤"></a>整合步骤</h5><p>1、 在pom.xml文件中引入redis相关依赖</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- redis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- spring2.X集成redis所需common-pool2--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、 application.properties配置redis配置</p>
 <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Redis服务器地址</span></span><br><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">192.168.140.136</span></span><br><span class="line"><span class="comment">#Redis服务器连接端口</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="comment">#Redis数据库索引（默认为0）</span></span><br><span class="line"><span class="meta">spring.redis.database</span>= <span class="string">0</span></span><br><span class="line"><span class="comment">#连接超时时间（毫秒）</span></span><br><span class="line"><span class="meta">spring.redis.timeout</span>=<span class="string">1800000</span></span><br><span class="line"><span class="comment">#连接池最大连接数（使用负值表示没有限制）</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-active</span>=<span class="string">20</span></span><br><span class="line"><span class="comment">#最大阻塞等待时间(负数表示没限制)</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-wait</span>=<span class="string">-1</span></span><br><span class="line"><span class="comment">#连接池中的最大空闲连接</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-idle</span>=<span class="string">5</span></span><br><span class="line"><span class="comment">#连接池中的最小空闲连接</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.min-idle</span>=<span class="string">0 </span></span><br></pre></td></tr></table></figure>

<p>3、 添加redis配置类</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> <span class="keyword">extends</span> <span class="title">CachingConfigurerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line"><span class="comment">//key序列化方式</span></span><br><span class="line">        template.setKeySerializer(redisSerializer);</span><br><span class="line"><span class="comment">//value序列化</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line"><span class="comment">//value hashmap序列化</span></span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line"><span class="comment">//解决查询缓存转换异常的问题</span></span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line"><span class="comment">// 配置序列化（解决乱码的问题）,过期时间600秒</span></span><br><span class="line">        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">                .entryTtl(Duration.ofSeconds(<span class="number">600</span>))</span><br><span class="line">                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))</span><br><span class="line">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))</span><br><span class="line">                .disableCachingNullValues();</span><br><span class="line">        RedisCacheManager cacheManager = RedisCacheManager.builder(factory)</span><br><span class="line">                .cacheDefaults(config)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>4、测试一下</p>
<p>RedisTestController中添加测试方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/redisTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testRedis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置值到redis</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;lucy&quot;</span>);</span><br><span class="line">        <span class="comment">//从redis获取值</span></span><br><span class="line">        String name = (String)redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/04/redis%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/10.Redis%E4%BA%8B%E5%8A%A1%E7%A7%92%E6%9D%80%E6%A1%88%E4%BE%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="核动力niuniu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="核动力niuniu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/04/redis%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/10.Redis%E4%BA%8B%E5%8A%A1%E7%A7%92%E6%9D%80%E6%A1%88%E4%BE%8B/" class="post-title-link" itemprop="url">10.Redis事务秒杀案例</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-04 22:20:24" itemprop="dateCreated datePublished" datetime="2022-01-04T22:20:24+08:00">2022-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-05 20:54:59" itemprop="dateModified" datetime="2022-01-05T20:54:59+08:00">2022-01-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="Redis事务秒杀案例"><a href="#Redis事务秒杀案例" class="headerlink" title="Redis事务秒杀案例"></a>Redis事务秒杀案例</h4><h5 id="解决计数器和人员记录的事务操作"><a href="#解决计数器和人员记录的事务操作" class="headerlink" title="解决计数器和人员记录的事务操作"></a>解决计数器和人员记录的事务操作</h5><p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsF6l7b4.png" alt="img"> </p>
<h5 id="Redis事务–秒杀并发模拟"><a href="#Redis事务–秒杀并发模拟" class="headerlink" title="Redis事务–秒杀并发模拟"></a>Redis事务–秒杀并发模拟</h5><p>使用工具ab模拟测试</p>
<p>CentOS6 默认安装</p>
<p>CentOS7需要手动安装</p>
<h6 id="联网：yum-install-httpd-tools"><a href="#联网：yum-install-httpd-tools" class="headerlink" title="联网：yum install httpd-tools"></a>联网：yum install httpd-tools</h6><h6 id="无网络"><a href="#无网络" class="headerlink" title="无网络"></a>无网络</h6><p>（1） 进入cd  /run/media/root/CentOS 7 x86_64/Packages（路径跟centos6不同）</p>
<p>（2） 顺序安装</p>
<p>apr-1.4.8-3.el7.x86_64.rpm</p>
<p>apr-util-1.5.2-6.el7.x86_64.rpm</p>
<p>httpd-tools-2.4.6-67.el7.centos.x86_64.rpm  </p>
<h6 id="测试及结果"><a href="#测试及结果" class="headerlink" title="测试及结果"></a>测试及结果</h6><ul>
<li>通过ab测试</li>
</ul>
<p>vim postfile 模拟表单提交参数,以&amp;符号结尾;存放当前目录。</p>
<p>内容：prodid=0101&amp;</p>
<p>ab -n 2000 -c 200 -k -p ~/postfile -T application/x-www-form-urlencoded <a target="_blank" rel="noopener" href="http://192.168.2.115:8081/Seckill/doseckill">http://192.168.2.115:8081/Seckill/doseckill</a></p>
<ul>
<li>超卖</li>
</ul>
<table>
<thead>
<tr>
<th><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsYqJIJA.png" alt="img"></th>
<th><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsdgdniw.png" alt="img"></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h5 id="超卖问题"><a href="#超卖问题" class="headerlink" title="超卖问题"></a>超卖问题</h5><p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsQ8oe0s.png" alt="img"> </p>
<h5 id="利用乐观锁淘汰用户，解决超卖问题。"><a href="#利用乐观锁淘汰用户，解决超卖问题。" class="headerlink" title="利用乐观锁淘汰用户，解决超卖问题。"></a>利用乐观锁淘汰用户，解决超卖问题。</h5><p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpskot0t5.png" alt="img"> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增加乐观锁</span></span><br><span class="line">jedis.watch(qtkey);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//3.判断库存</span></span><br><span class="line">String qtkeystr = jedis.get(qtkey);</span><br><span class="line"><span class="keyword">if</span>(qtkeystr==<span class="keyword">null</span> || <span class="string">&quot;&quot;</span>.equals(qtkeystr.trim())) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;未初始化库存&quot;</span>);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span> ;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> qt = Integer.parseInt(qtkeystr);</span><br><span class="line"><span class="keyword">if</span>(qt&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">System.err.println(<span class="string">&quot;已经秒光&quot;</span>);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//增加事务</span></span><br><span class="line">Transaction multi = jedis.multi();</span><br><span class="line"> </span><br><span class="line"><span class="comment">//4.减少库存</span></span><br><span class="line"><span class="comment">//jedis.decr(qtkey);</span></span><br><span class="line">multi.decr(qtkey);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//5.加人</span></span><br><span class="line"><span class="comment">//jedis.sadd(usrkey, uid);</span></span><br><span class="line">multi.sadd(usrkey, uid);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//执行事务</span></span><br><span class="line">List&lt;Object&gt; list = multi.exec();</span><br><span class="line"> </span><br><span class="line"><span class="comment">//判断事务提交是否失败</span></span><br><span class="line"><span class="keyword">if</span>(list==<span class="keyword">null</span> || list.size()==<span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;秒杀失败&quot;</span>);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.err.println(<span class="string">&quot;秒杀成功&quot;</span>);</span><br><span class="line">jedis.close();</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/image-20211106212045210.png" alt="image-20211106212045210"></p>
<img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/image-20211106212111139.png" alt="image-20211106212111139" style="zoom:15%;" />



<h5 id="继续增加并发测试"><a href="#继续增加并发测试" class="headerlink" title="继续增加并发测试"></a>继续增加并发测试</h5><h6 id="连接有限制"><a href="#连接有限制" class="headerlink" title="连接有限制"></a>连接有限制</h6><p>ab -n 2000 -c 200 -k -p postfile -T ‘application/x-www-form-urlencoded’ <a target="_blank" rel="noopener" href="http://192.168.140.1:8080/seckill/doseckill">http://192.168.140.1:8080/seckill/doseckill</a></p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsCPJ9L3.png" alt="img"> </p>
<p>增加-r参数，-r  Don’t exit on socket receive errors.</p>
<p>ab -n 2000 -c 100 -r -p postfile -T ‘application/x-www-form-urlencoded’ <a target="_blank" rel="noopener" href="http://192.168.140.1:8080/seckill/doseckill">http://192.168.140.1:8080/seckill/doseckill</a></p>
<h6 id="已经秒光，可是还有库存"><a href="#已经秒光，可是还有库存" class="headerlink" title="已经秒光，可是还有库存"></a>已经秒光，可是还有库存</h6><p>ab -n 2000 -c 100 -p postfile -T ‘application/x-www-form-urlencoded’ <a target="_blank" rel="noopener" href="http://192.168.137.1:8080/seckill/doseckill">http://192.168.137.1:8080/seckill/doseckill</a></p>
<p>已经秒光，可是还有库存。原因，就是乐观锁导致很多请求都失败。先点的没秒到，后点的可能秒到了。</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsE9sw56.png" alt="img"> </p>
<h6 id="连接超时，通过连接池解决"><a href="#连接超时，通过连接池解决" class="headerlink" title="连接超时，通过连接池解决"></a>连接超时，通过连接池解决</h6><p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsvwqg8S.png" alt="img"> </p>
<h6 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h6><p>节省每次连接redis服务带来的消耗，把连接好的实例反复利用。</p>
<p>通过参数管理连接的行为</p>
<p>代码见项目中</p>
<ul>
<li><p>链接池参数</p>
<ol>
<li><p>MaxTotal：控制一个pool可分配多少个jedis实例，通过pool.getResource()来获取；如果赋值为-1，则表示不限制；如果pool已经分配了MaxTotal个jedis实例，则此时pool的状态为exhausted。</p>
</li>
<li><p>maxIdle：控制一个pool最多有多少个状态为idle(空闲)的jedis实例；</p>
</li>
<li><p>MaxWaitMillis：表示当borrow一个jedis实例时，最大的等待毫秒数，如果超过等待时间，则直接抛JedisConnectionException；</p>
</li>
<li><p>testOnBorrow：获得一个jedis实例的时候是否检查连接可用性（ping()）；如果为true，则得到的jedis实例均是可用的；</p>
</li>
</ol>
</li>
</ul>
<h5 id="解决库存遗留问题"><a href="#解决库存遗留问题" class="headerlink" title="解决库存遗留问题"></a>解决库存遗留问题</h5><h6 id="LUA脚本"><a href="#LUA脚本" class="headerlink" title="LUA脚本"></a>LUA脚本</h6><p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsI1k8hg.png" alt="img"> </p>
<p>Lua 是一个小巧的<a target="_blank" rel="noopener" href="http://baike.baidu.com/item/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80">脚本语言</a>，Lua脚本可以很容易的被C/C++ 代码调用，也可以反过来调用C/C++的函数，Lua并没有提供强大的库，一个完整的Lua解释器不过200k，所以Lua不适合作为开发独立应用程序的语言，而是作为嵌入式脚本语言。</p>
<p>很多应用程序、游戏使用LUA作为自己的嵌入式脚本语言，以此来实现可配置性、可扩展性。</p>
<p>这其中包括魔兽争霸地图、魔兽世界、博德之门、愤怒的小鸟等众多游戏插件或外挂。</p>
<p><a target="_blank" rel="noopener" href="https://www.w3cschool.cn/lua/">https://www.w3cschool.cn/lua/</a></p>
<h6 id="LUA脚本在Redis中的优势"><a href="#LUA脚本在Redis中的优势" class="headerlink" title="LUA脚本在Redis中的优势"></a>LUA脚本在Redis中的优势</h6><p>将复杂的或者多步的redis操作，写为一个脚本，一次提交给redis执行，减少反复连接redis的次数。提升性能。</p>
<p>LUA脚本是类似redis事务，有一定的原子性，不会被其他命令插队，可以完成一些redis事务性的操作。</p>
<p>但是注意redis的lua脚本功能，只有在Redis 2.6以上的版本才可以使用。</p>
<p>利用lua脚本淘汰用户，解决超卖问题。</p>
<p>redis 2.6版本以后，通过lua脚本解决争抢问题，实际上是redis 利用其单线程的特性，用任务队列的方式解决多任务并发问题。</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsUcaXHN.png" alt="img"> </p>
<h5 id="Redis-事务-秒杀案例-代码"><a href="#Redis-事务-秒杀案例-代码" class="headerlink" title="Redis_事务_秒杀案例_代码"></a>Redis_事务_秒杀案例_代码</h5><h6 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h6><p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpskjxSZ8.jpg" alt="img"> </p>
<h6 id="第一版：简单版"><a href="#第一版：简单版" class="headerlink" title="第一版：简单版"></a>第一版：简单版</h6><p>老师点10次，正常秒杀</p>
<p>同学一起点试一试，秒杀也是正常的。这是因为还达不到并发的效果。</p>
<p>使用工具ab模拟并发测试，会出现超卖情况。查看库存会出现负数。</p>
<h6 id="第二版：加事务-乐观锁-解决超卖-但出现遗留库存和连接超时"><a href="#第二版：加事务-乐观锁-解决超卖-但出现遗留库存和连接超时" class="headerlink" title="第二版：加事务-乐观锁(解决超卖),但出现遗留库存和连接超时"></a>第二版：加事务-乐观锁(解决超卖),但出现遗留库存和连接超时</h6><h6 id="第三版：连接池解决超时问题"><a href="#第三版：连接池解决超时问题" class="headerlink" title="第三版：连接池解决超时问题"></a>第三版：连接池解决超时问题</h6><h6 id="第四版：解决库存依赖问题，LUA脚本"><a href="#第四版：解决库存依赖问题，LUA脚本" class="headerlink" title="第四版：解决库存依赖问题，LUA脚本"></a>第四版：解决库存依赖问题，LUA脚本</h6><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> userid=KEYS[<span class="number">1</span>]; </span><br><span class="line"><span class="keyword">local</span> prodid=KEYS[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">local</span> qtkey=<span class="string">&quot;sk:&quot;</span>..prodid..<span class="string">&quot;:qt&quot;</span>;</span><br><span class="line"><span class="keyword">local</span> usersKey=<span class="string">&quot;sk:&quot;</span>..prodid.<span class="string">&quot;:usr&#x27;; </span></span><br><span class="line"><span class="string">local userExists=redis.call(&quot;</span>sismember<span class="string">&quot;,usersKey,userid);</span></span><br><span class="line"><span class="string">if tonumber(userExists)==1 then </span></span><br><span class="line"><span class="string">  return 2;</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">local num= redis.call(&quot;</span>get<span class="string">&quot; ,qtkey);</span></span><br><span class="line"><span class="string">if tonumber(num)&lt;=0 then </span></span><br><span class="line"><span class="string">  return 0; </span></span><br><span class="line"><span class="string">else </span></span><br><span class="line"><span class="string">  redis.call(&quot;</span>decr<span class="string">&quot;,qtkey);</span></span><br><span class="line"><span class="string">  redis.call(&quot;</span>sadd<span class="string">&quot;,usersKey,userid);</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">return 1;</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/04/redis%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/11.Redis%E6%8C%81%E4%B9%85%E5%8C%96%E4%B9%8BRDB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="核动力niuniu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="核动力niuniu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/04/redis%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/11.Redis%E6%8C%81%E4%B9%85%E5%8C%96%E4%B9%8BRDB/" class="post-title-link" itemprop="url">11.Redis持久化之RDB</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-04 22:20:24" itemprop="dateCreated datePublished" datetime="2022-01-04T22:20:24+08:00">2022-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-05 20:36:15" itemprop="dateModified" datetime="2022-01-05T20:36:15+08:00">2022-01-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="Redis持久化之RDB"><a href="#Redis持久化之RDB" class="headerlink" title="Redis持久化之RDB"></a>Redis持久化之RDB</h4><h5 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h5><p>官网介绍：<a target="_blank" rel="noopener" href="http://www.redis.io/">http://www.redis.io</a></p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsM9NzJ9.png" alt="img"> </p>
<p>Redis 提供了2个不同形式的持久化方式。</p>
<ul>
<li><p>RDB（Redis DataBase）</p>
</li>
<li><p>AOF（Append Of File）</p>
</li>
</ul>
<h5 id="RDB（Redis-DataBase）"><a href="#RDB（Redis-DataBase）" class="headerlink" title="RDB（Redis DataBase）"></a>RDB（Redis DataBase）</h5><h6 id="官网介绍"><a href="#官网介绍" class="headerlink" title="官网介绍"></a>官网介绍</h6><p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsaIXXxk.png" alt="img"> </p>
<h6 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h6><p>在指定的时间间隔内将内存中的数据集快照写入磁盘， 也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里</p>
<h6 id="备份是如何执行的"><a href="#备份是如何执行的" class="headerlink" title="备份是如何执行的"></a>备份是如何执行的</h6><p>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到 一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。 整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能 如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。</p>
<h6 id="Fork"><a href="#Fork" class="headerlink" title="Fork"></a>Fork</h6><ul>
<li><p>Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程</p>
</li>
<li><p>在Linux程序中，fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，Linux中引入了“写时复制技术”</p>
</li>
<li><p>一般情况父进程和子进程会共用同一段物理内存，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。</p>
</li>
</ul>
<h6 id="RDB持久化流程"><a href="#RDB持久化流程" class="headerlink" title="RDB持久化流程"></a>RDB持久化流程</h6><p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsJjacp1.jpg" alt="img"> </p>
<h6 id="dump-rdb文件"><a href="#dump-rdb文件" class="headerlink" title="dump.rdb文件"></a>dump.rdb文件</h6><p>在redis.conf中配置文件名称，默认为dump.rdb</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsRVvGMU.jpg" alt="img"> </p>
<h6 id="配置位置"><a href="#配置位置" class="headerlink" title="配置位置"></a>配置位置</h6><p>rdb文件的保存路径，也可以修改。默认为Redis启动时命令行所在的目录下</p>
<p>dir “/myredis/“</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpstHPBD6.jpg" alt="img"> </p>
<h6 id="如何触发RDB快照；保持策略"><a href="#如何触发RDB快照；保持策略" class="headerlink" title="如何触发RDB快照；保持策略"></a>如何触发RDB快照；保持策略</h6><ul>
<li>配置文件中默认的快照配置</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsstk9l0.jpg" alt="img"> </p>
<ul>
<li><p>命令save VS bgsave</p>
<p>save ：save时只管保存，其它不管，全部阻塞。手动保存。不建议。</p>
<p>bgsave：Redis会在后台异步进行快照操作， 快照同时还可以响应客户端请求。</p>
<p>可以通过lastsave 命令获取最后一次成功执行快照的时间</p>
</li>
<li><p>flushall命令</p>
<p>执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义</p>
</li>
<li><p>SNAPSHOTTING快照</p>
</li>
<li><p>Save</p>
<p>格式：save 秒钟 写操作次数</p>
<p>RDB是整个内存的压缩过的Snapshot，RDB的数据结构，可以配置复合的快照触发条件，</p>
<p>默认是1分钟内改了1万次，或5分钟内改了10次，或15分钟内改了1次。</p>
<p>禁用</p>
<p>不设置save指令，或者给save传入空字符串</p>
</li>
<li><p>stop-writes-on-bgsave-error</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsEWXNVg.jpg" alt="img"> </p>
<p>​    当Redis无法写入磁盘的话，直接关掉Redis的写操作。推荐yes.</p>
<ul>
<li>rdbcompression 压缩文件</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsoZEIFD.jpg" alt="img"> </p>
<p>​    对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。</p>
<p>如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能。推荐yes.</p>
<ul>
<li>rdbchecksum 检查完整性</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsmHDA4E.jpg" alt="img"> </p>
<p>在存储快照后，还可以让redis使用CRC64算法来进行数据校验，</p>
<p>但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能</p>
<p>推荐yes.</p>
<ul>
<li><p>rdb的备份</p>
<p>先通过config get dir  查询rdb文件的目录 </p>
<p>将*.rdb的文件拷贝到别的地方</p>
<p>rdb的恢复</p>
<p>关闭Redis</p>
<p>先把备份的文件拷贝到工作目录下 cp dump2.rdb dump.rdb</p>
<p>启动Redis, 备份数据会直接加载</p>
</li>
</ul>
<h6 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h6><ul>
<li><p>适合大规模的数据恢复</p>
</li>
<li><p>对数据完整性和一致性要求不高更适合使用</p>
</li>
<li><p>节省磁盘空间</p>
</li>
<li><p>恢复速度快</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsX3DV2t.png" alt="img"> </p>
<h6 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h6><p>l Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑</p>
<p>l 虽然Redis在fork时使用了写时拷贝技术,但是如果数据庞大时还是比较消耗性能。</p>
<p>l 在备份周期在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改。</p>
<h6 id="如何停止"><a href="#如何停止" class="headerlink" title="如何停止"></a>如何停止</h6><p>动态停止RDB：redis-cli config set save “”#save后给空值，表示禁用保存策略</p>
<h6 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h6><p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wps1ZcZDR.png" alt="img"> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">核动力niuniu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">30</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">核动力niuniu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
