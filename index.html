<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="核动力niuniu">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="核动力niuniu">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="核动力niuniu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>核动力niuniu</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">核动力niuniu</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/04/k8s%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/1.Kubernetes%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="核动力niuniu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="核动力niuniu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/04/k8s%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/1.Kubernetes%E4%BB%8B%E7%BB%8D/" class="post-title-link" itemprop="url">1.Kubernetes介绍</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-04 22:20:24" itemprop="dateCreated datePublished" datetime="2022-01-04T22:20:24+08:00">2022-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-05 01:28:13" itemprop="dateModified" datetime="2022-01-05T01:28:13+08:00">2022-01-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Kubernetes详细教程"><a href="#Kubernetes详细教程" class="headerlink" title="Kubernetes详细教程"></a>Kubernetes详细教程</h2><h3 id="Kubernetes介绍"><a href="#Kubernetes介绍" class="headerlink" title="Kubernetes介绍"></a>Kubernetes介绍</h3><h4 id="应用部署方式演变"><a href="#应用部署方式演变" class="headerlink" title="应用部署方式演变"></a>应用部署方式演变</h4><p>在部署应用程序的方式上，主要经历了三个时代：</p>
<ul>
<li><p><strong>传统部署</strong>：互联网早期，会直接将应用程序部署在物理机上</p>
<blockquote>
<p>优点：简单，不需要其它技术的参与</p>
<p>缺点：不能为应用程序定义资源使用边界，很难合理地分配计算资源，而且程序之间容易产生影响</p>
</blockquote>
</li>
<li><p><strong>虚拟化部署</strong>：可以在一台物理机上运行多个虚拟机，每个虚拟机都是独立的一个环境</p>
<blockquote>
<p>优点：程序环境不会相互产生影响，提供了一定程度的安全性</p>
<p>缺点：增加了操作系统，浪费了部分资源</p>
</blockquote>
</li>
<li><p><strong>容器化部署</strong>：与虚拟化类似，但是共享了操作系统</p>
<blockquote>
<p>优点：</p>
<p>可以保证每个容器拥有自己的文件系统、CPU、内存、进程空间等</p>
<p>运行应用程序所需要的资源都被容器包装，并和底层基础架构解耦</p>
<p>容器化的应用程序可以跨云服务商、跨Linux操作系统发行版进行部署</p>
</blockquote>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/k8s/Kubenetes.assets/image-20200505183738289.png" alt="image-20200505183738289"></p>
<p>容器化部署方式给带来很多的便利，但是也会出现一些问题，比如说：</p>
<ul>
<li>一个容器故障停机了，怎么样让另外一个容器立刻启动去替补停机的容器</li>
<li>当并发访问量变大的时候，怎么样做到横向扩展容器数量</li>
</ul>
<p>这些容器管理的问题统称为<strong>容器编排</strong>问题，为了解决这些容器编排问题，就产生了一些容器编排的软件：</p>
<ul>
<li><strong>Swarm</strong>：Docker自己的容器编排工具</li>
<li><strong>Mesos</strong>：Apache的一个资源统一管控的工具，需要和Marathon结合使用</li>
<li><strong>Kubernetes</strong>：Google开源的的容器编排工具</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/k8s/Kubenetes.assets/image-20200524150339551.png" alt="image-20200524150339551"></p>
<h4 id="kubernetes简介"><a href="#kubernetes简介" class="headerlink" title="kubernetes简介"></a>kubernetes简介</h4><p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/k8s/Kubenetes.assets/image-20200406232838722.png" alt="image-20200406232838722"></p>
<p>kubernetes，是一个全新的基于容器技术的分布式架构领先方案，是谷歌严格保密十几年的秘密武器—-Borg系统的一个开源版本，于2014年9月发布第一个版本，2015年7月发布第一个正式版本。</p>
<p>kubernetes的本质是<strong>一组服务器集群</strong>，它可以在集群的每个节点上运行特定的程序，来对节点中的容器进行管理。目的是实现资源管理的自动化，主要提供了如下的主要功能：</p>
<ul>
<li><strong>自我修复</strong>：一旦某一个容器崩溃，能够在1秒中左右迅速启动新的容器</li>
<li><strong>弹性伸缩</strong>：可以根据需要，自动对集群中正在运行的容器数量进行调整</li>
<li><strong>服务发现</strong>：服务可以通过自动发现的形式找到它所依赖的服务</li>
<li><strong>负载均衡</strong>：如果一个服务起动了多个容器，能够自动实现请求的负载均衡</li>
<li><strong>版本回退</strong>：如果发现新发布的程序版本有问题，可以立即回退到原来的版本</li>
<li><strong>存储编排</strong>：可以根据容器自身的需求自动创建存储卷</li>
</ul>
<h4 id="kubernetes组件"><a href="#kubernetes组件" class="headerlink" title="kubernetes组件"></a>kubernetes组件</h4><p>一个kubernetes集群主要是由**控制节点(master)<strong>、</strong>工作节点(node)**构成，每个节点上都会安装不同的组件。</p>
<p><strong>master：集群的控制平面，负责集群的决策 ( 管理 )</strong></p>
<blockquote>
<p><strong>ApiServer</strong> : 资源操作的唯一入口，接收用户输入的命令，提供认证、授权、API注册和发现等机制</p>
<p><strong>Scheduler</strong> : 负责集群资源调度，按照预定的调度策略将Pod调度到相应的node节点上</p>
<p><strong>ControllerManager</strong> : 负责维护集群的状态，比如程序部署安排、故障检测、自动扩展、滚动更新等</p>
<p><strong>Etcd</strong> ：负责存储集群中各种资源对象的信息</p>
</blockquote>
<p><strong>node：集群的数据平面，负责为容器提供运行环境 ( 干活 )</strong></p>
<blockquote>
<p><strong>Kubelet</strong> : 负责维护容器的生命周期，即通过控制docker，来创建、更新、销毁容器</p>
<p><strong>KubeProxy</strong> : 负责提供集群内部的服务发现和负载均衡</p>
<p><strong>Docker</strong> : 负责节点上容器的各种操作</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/k8s/Kubenetes.assets/image-20200406184656917.png" alt="image-20200406184656917"></p>
<p>下面，以部署一个nginx服务来说明kubernetes系统各个组件调用关系：</p>
<ol>
<li><p>首先要明确，一旦kubernetes环境启动之后，master和node都会将自身的信息存储到etcd数据库中</p>
</li>
<li><p>一个nginx服务的安装请求会首先被发送到master节点的apiServer组件</p>
</li>
<li><p>apiServer组件会调用scheduler组件来决定到底应该把这个服务安装到哪个node节点上</p>
<p>在此时，它会从etcd中读取各个node节点的信息，然后按照一定的算法进行选择，并将结果告知apiServer</p>
</li>
<li><p>apiServer调用controller-manager去调度Node节点安装nginx服务</p>
</li>
<li><p>kubelet接收到指令后，会通知docker，然后由docker来启动一个nginx的pod</p>
<p>pod是kubernetes的最小操作单元，容器必须跑在pod中至此，</p>
</li>
<li><p>一个nginx服务就运行了，如果需要访问nginx，就需要通过kube-proxy来对pod产生访问的代理</p>
</li>
</ol>
<p>这样，外界用户就可以访问集群中的nginx服务了</p>
<h4 id="kubernetes概念"><a href="#kubernetes概念" class="headerlink" title="kubernetes概念"></a>kubernetes概念</h4><p><strong>Master</strong>：集群控制节点，每个集群需要至少一个master节点负责集群的管控</p>
<p><strong>Node</strong>：工作负载节点，由master分配容器到这些node工作节点上，然后node节点上的docker负责容器的运行</p>
<p><strong>Pod</strong>：kubernetes的最小控制单元，容器都是运行在pod中的，一个pod中可以有1个或者多个容器</p>
<p><strong>Controller</strong>：控制器，通过它来实现对pod的管理，比如启动pod、停止pod、伸缩pod的数量等等</p>
<p><strong>Service</strong>：pod对外服务的统一入口，下面可以维护者同一类的多个pod</p>
<p><strong>Label</strong>：标签，用于对pod进行分类，同一类pod会拥有相同的标签</p>
<p><strong>NameSpace</strong>：命名空间，用来隔离pod的运行环境</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/04/redis%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/1.NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="核动力niuniu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="核动力niuniu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/04/redis%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/1.NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">1.NoSQL数据库简介</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-04 22:20:24" itemprop="dateCreated datePublished" datetime="2022-01-04T22:20:24+08:00">2022-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-05 20:17:44" itemprop="dateModified" datetime="2022-01-05T20:17:44+08:00">2022-01-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="NoSQL数据库简介"><a href="#NoSQL数据库简介" class="headerlink" title="NoSQL数据库简介"></a>NoSQL数据库简介</h4><h5 id="技术发展"><a href="#技术发展" class="headerlink" title="技术发展"></a>技术发展</h5><p>技术的分类</p>
<p>1、解决功能性的问题：Java、Jsp、RDBMS、Tomcat、HTML、Linux、JDBC、SVN</p>
<p>2、解决扩展性的问题：Struts、Spring、SpringMVC、Hibernate、Mybatis</p>
<p>3、解决性能的问题：NoSQL、Java线程、Hadoop、Nginx、MQ、ElasticSearch</p>
<h6 id="Web1-0时代"><a href="#Web1-0时代" class="headerlink" title="Web1.0时代"></a>Web1.0时代</h6><p>Web1.0的时代，数据访问量很有限，用一夫当关的高性能的单点服务器可以解决大部分问题。</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/image-20211106223642396.png" alt="image-20211106223642396"></p>
<h6 id="Web2-0时代"><a href="#Web2-0时代" class="headerlink" title="Web2.0时代"></a>Web2.0时代</h6><p>随着Web2.0的时代的到来，用户访问量大幅度提升，同时产生了大量的用户数据。加上后来的智能移动设备的普及，所有的互联网平台都面临了巨大的性能挑战。</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/image-20211106175858853.png" alt="image-20211106175858853"> </p>
<h6 id="解决CPU及内存压力"><a href="#解决CPU及内存压力" class="headerlink" title="解决CPU及内存压力"></a>解决CPU及内存压力</h6><p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsnBGq2y.png" alt="img"> </p>
<h6 id="解决IO压力"><a href="#解决IO压力" class="headerlink" title="解决IO压力"></a>解决IO压力</h6><p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpse2F612.png" alt="img"> </p>
<h5 id="NoSQL数据库"><a href="#NoSQL数据库" class="headerlink" title="NoSQL数据库"></a>NoSQL数据库</h5><h6 id="NoSQL数据库概述"><a href="#NoSQL数据库概述" class="headerlink" title="NoSQL数据库概述"></a>NoSQL数据库概述</h6><p>NoSQL(NoSQL = <strong>Not Only SQL</strong>)，意即“不仅仅是SQL”，泛指<strong>非关系型的数据库</strong>。 </p>
<p>NoSQL 不依赖业务逻辑方式存储，而以简单的key-value模式存储。因此大大的增加了数据库的扩展能力。</p>
<ul>
<li><p>不遵循SQL标准。</p>
</li>
<li><p>不支持ACID。</p>
</li>
<li><p>远超于SQL的性能。</p>
</li>
</ul>
<h6 id="NoSQL适用场景"><a href="#NoSQL适用场景" class="headerlink" title="NoSQL适用场景"></a>NoSQL适用场景</h6><ul>
<li><p>对数据高并发的读写</p>
</li>
<li><p>海量数据的读写</p>
</li>
<li><p>对数据高可扩展性的</p>
</li>
</ul>
<h6 id="NoSQL不适用场景"><a href="#NoSQL不适用场景" class="headerlink" title="NoSQL不适用场景"></a>NoSQL不适用场景</h6><ul>
<li><p>需要事务支持</p>
</li>
<li><p>基于sql的结构化查询存储，处理复杂的关系,需要即席查询。</p>
</li>
<li><p>用不着sql的和用了sql也不行的情况，请考虑用NoSql）</p>
</li>
</ul>
<h6 id="Memcache"><a href="#Memcache" class="headerlink" title="Memcache"></a>Memcache</h6><table>
<thead>
<tr>
<th><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsC3MRJ1.png" alt="img" style="zoom:75%;" /></th>
<th>ü 很早出现的NoSql数据库ü 数据都在内存中，一般不持久化ü 支持简单的key-value模式，支持类型单一ü 一般是作为缓存数据库辅助持久化的数据库</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h6 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h6><table>
<thead>
<tr>
<th><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsxexKeP.png" alt="img"></th>
<th>几乎覆盖了Memcached的绝大部分功能数据都在内存中，支持持久化，主要用作备份恢复除了支持简单的key-value模式，还支持多种数据结构的存储，比如 list、set、hash、zset等。一般是作为缓存数据库辅助持久化的数据库</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h6 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h6><table>
<thead>
<tr>
<th><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images//images/wps9uGosP.png" alt="img"></th>
<th>ü 高性能、开源、模式自由(schema  free)的文档型数据库ü 数据都在内存中， 如果内存不足，把不常用的数据保存到硬盘ü 虽然是key-value模式，但是对value（尤其是json）提供了丰富的查询功能ü 支持二进制数据及大型对象ü 可以根据数据的特点替代RDBMS ，成为独立的数据库。或者配合RDBMS，存储特定的数据。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h5 id="行式存储数据库（大数据时代）"><a href="#行式存储数据库（大数据时代）" class="headerlink" title="行式存储数据库（大数据时代）"></a>行式存储数据库（大数据时代）</h5><h6 id="行式数据库"><a href="#行式数据库" class="headerlink" title="行式数据库"></a>行式数据库</h6><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsP36kKk.png" alt="img" style="zoom:75%;" /> 

<h6 id="列式数据库"><a href="#列式数据库" class="headerlink" title="列式数据库"></a>列式数据库</h6><p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsxy3fnz.png" alt="img"> </p>
<p>Hbase</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsQHkGeH.png" alt="img"> </p>
<p>HBase是Hadoop项目中的数据库。它用于需要对大量的数据进行随机、实时的读写操作的场景中。</p>
<p>HBase的目标就是处理数据量非常庞大的表，可以用普通的计算机处理超过10亿行数据，还可处理有数百万列元素的数据表。</p>
<p>Cassandra[kəˈsændrə]</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsaK86nQ.png" alt="img"> </p>
<p>Apache Cassandra是一款免费的开源NoSQL数据库，其设计目的在于管理由大量商用服务器构建起来的庞大集群上的海量数据集(数据量通常达到PB级别)。在众多显著特性当中，Cassandra最为卓越的长处是对写入及读取操作进行规模调整，而且其不强调主集群的设计思路能够以相对直观的方式简化各集群的创建与扩展流程。</p>
<blockquote>
<p>计算机存储单位 计算机存储单位一般用B，KB，MB，GB，TB，EB，ZB，YB，BB来表示，它们之间的关系是：</p>
<p>位 bit (比特)(Binary Digits)：存放一位二进制数，即 0 或 1，最小的存储单位。</p>
<p>字节 byte：8个二进制位为一个字节(B)，最常用的单位。</p>
<p>1KB (Kilobyte 千字节)=1024B，</p>
<p>1MB (Megabyte 兆字节 简称“兆”)=1024KB，</p>
<p>1GB (Gigabyte 吉字节 又称“千兆”)=1024MB，</p>
<p>1TB (Trillionbyte 万亿字节 太字节)=1024GB，其中1024=2^10 ( 2 的10次方)，</p>
<p>1PB（Petabyte 千万亿字节 拍字节）=1024TB，</p>
<p>1EB（Exabyte 百亿亿字节 艾字节）=1024PB，</p>
<p>1ZB (Zettabyte 十万亿亿字节 泽字节)= 1024 EB,</p>
<p>1YB (Jottabyte 一亿亿亿字节 尧字节)= 1024 ZB,</p>
<p>1BB (Brontobyte 一千亿亿亿字节)= 1024 YB.</p>
<p>注：“兆”为百万级数量单位。</p>
</blockquote>
<h5 id="图关系型数据库"><a href="#图关系型数据库" class="headerlink" title="图关系型数据库"></a>图关系型数据库</h5><p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsIkF7t0.png" alt="img"> </p>
<p>主要应用：社会关系，公共交通网络，地图及网络拓谱(n*(n-1)/2)</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsFBhaQX.png" alt="img"> </p>
<h5 id="DB-Engines-数据库排名"><a href="#DB-Engines-数据库排名" class="headerlink" title="DB-Engines 数据库排名"></a>DB-Engines 数据库排名</h5><p><a target="_blank" rel="noopener" href="http://db-engines.com/en/ranking">http://db-engines.com/en/ranking</a></p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsb5t8zl.jpg" alt="img"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/04/redis%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/2.Redis%E6%A6%82%E8%BF%B0%E5%AE%89%E8%A3%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="核动力niuniu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="核动力niuniu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/04/redis%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/2.Redis%E6%A6%82%E8%BF%B0%E5%AE%89%E8%A3%85/" class="post-title-link" itemprop="url">2.Redis概述安装</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-04 22:20:24" itemprop="dateCreated datePublished" datetime="2022-01-04T22:20:24+08:00">2022-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-05 20:22:03" itemprop="dateModified" datetime="2022-01-05T20:22:03+08:00">2022-01-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="Redis概述安装"><a href="#Redis概述安装" class="headerlink" title="Redis概述安装"></a>Redis概述安装</h4><p>Ø Redis是一个开源的key-value存储系统。</p>
<p>Ø 和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。</p>
<p>Ø 这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。</p>
<p>Ø 在此基础上，Redis支持各种不同方式的排序。</p>
<p>Ø 与memcached一样，为了保证效率，数据都是缓存在内存中。</p>
<p>Ø 区别的是Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件。</p>
<p>Ø 并且在此基础上实现了master-slave(主从)同步。</p>
<h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><h6 id="配合关系型数据库做高速缓存"><a href="#配合关系型数据库做高速缓存" class="headerlink" title="配合关系型数据库做高速缓存"></a>配合关系型数据库做高速缓存</h6><p>Ø 高频次，热门访问的数据，降低数据库IO</p>
<p>Ø 分布式架构，做session共享</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsDF5ASI.png" alt="img"> </p>
<h6 id="多样的数据结构存储持久化数据"><a href="#多样的数据结构存储持久化数据" class="headerlink" title="多样的数据结构存储持久化数据"></a>多样的数据结构存储持久化数据</h6><p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsIRdcFW.png" alt="img"> </p>
<h5 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h5><table>
<thead>
<tr>
<th>Redis官方网站</th>
<th>Redis中文官方网站</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="http://redis.io/">http://redis.io</a></td>
<td><a target="_blank" rel="noopener" href="http://redis.cn/">http://redis.cn/</a></td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsmUsI3S.jpg" alt="img"> </p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsCvIJto.jpg" alt="img"> </p>
<h6 id="安装版本"><a href="#安装版本" class="headerlink" title="安装版本"></a>安装版本</h6><p>Ø 6.2.1 for Linux（redis-6.2.1.tar.gz）</p>
<p>Ø 不用考虑在windows环境下对Redis的支持</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpswAbLaj.png" alt="img"> </p>
<h6 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h6><p>准备工作：下载安装最新版的gcc编译器</p>
<h6 id="安装C-语言的编译环境"><a href="#安装C-语言的编译环境" class="headerlink" title="安装C 语言的编译环境"></a>安装C 语言的编译环境</h6><ul>
<li><p>yum install centos-release-scl scl-utils-build</p>
</li>
<li><p>yum install -y devtoolset-8-toolchain</p>
</li>
<li><p>scl enable devtoolset-8 bash</p>
</li>
</ul>
<p>测试 gcc版本 </p>
<ul>
<li>gcc –version</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsfo4FjS.jpg" alt="img"> </p>
<ul>
<li><p>下载redis-6.2.1.tar.gz放/opt目录</p>
</li>
<li><p>解压命令：tar -zxvf redis-6.2.1.tar.gz</p>
</li>
<li><p>解压完成后进入目录：cd redis-6.2.1</p>
</li>
<li><p>在redis-6.2.1目录下再次执行make命令（只是编译好）</p>
</li>
<li><p>如果没有准备好C语言编译环境，make 会报错—Jemalloc/jemalloc.h：没有那个文件</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpstuXSqk.png" alt="img"> </p>
<ul>
<li>解决方案：运行make distclean</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsrmmhyP.png" alt="img"> </p>
<ul>
<li>在redis-6.2.1目录下再次执行make命令（只是编译好）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wps6pB91g.png" alt="img"> </p>
<ul>
<li>跳过make test 继续执行: make install</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpskxuaN8.png" alt="img"> </p>
<h6 id="安装目录：-usr-local-bin"><a href="#安装目录：-usr-local-bin" class="headerlink" title="安装目录：/usr/local/bin"></a>安装目录：/usr/local/bin</h6><p>​    查看默认安装目录：</p>
<p>​    redis-benchmark:性能测试工具，可以在自己本子运行，看看自己本子性能如何</p>
<p>​    redis-check-aof：修复有问题的AOF文件，rdb和aof后面讲</p>
<p>​    redis-check-dump：修复有问题的dump.rdb文件</p>
<p>​    redis-sentinel：Redis集群使用</p>
<p>​    redis-server：Redis服务器启动命令</p>
<p>​    redis-cli：客户端，操作入口</p>
<h6 id="前台启动（不推荐）"><a href="#前台启动（不推荐）" class="headerlink" title="前台启动（不推荐）"></a>前台启动（不推荐）</h6><p>前台启动，命令行窗口不能关闭，否则服务器停止</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsaBCDxO.png" alt="img"> </p>
<h6 id="后台启动（推荐）"><a href="#后台启动（推荐）" class="headerlink" title="后台启动（推荐）"></a>后台启动（推荐）</h6><ol>
<li><p><strong>备份redis.conf</strong></p>
<p>拷贝一份redis.conf到其他目录</p>
<p>cp  /opt/redis-3.2.5/redis.conf  /myredis</p>
</li>
<li><p><strong>后台启动设置daemonize no改成yes</strong></p>
<p>修改redis.conf(128行)文件将里面的daemonize no 改成 yes，让服务在后台启动</p>
</li>
<li><p><strong>Redis启动</strong></p>
<p>redis-server/myredis/redis.conf</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpssZK7Oq.png" alt="img"> </p>
<ol start="4">
<li>用客户端访问：redis-cli</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsWTcXm7.png" alt="img"> </p>
<ol start="5">
<li><p>多个端口可以：redis-cli -p6379</p>
</li>
<li><p>测试验证： ping</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wps7UBIz5.png" alt="img"> </p>
<ol start="7">
<li><p>Redis关闭</p>
<p>单实例关闭：redis-cli shutdown</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsg5dXyO.png" alt="img"> </p>
<p>也可以进入终端后再关闭</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsoRIYTV.png" alt="img"> </p>
<p>多实例关闭，指定端口关闭：redis-cli -p 6379 shutdown</p>
<h6 id="Redis介绍相关知识"><a href="#Redis介绍相关知识" class="headerlink" title="Redis介绍相关知识"></a>Redis介绍相关知识</h6><table>
<thead>
<tr>
<th>端口6379从何而来Alessia  Merz<img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsI3kNRH.png" alt="img"></th>
<th>默认16个数据库，类似数组下标从0开始，初始默认使用0号库使用命令 select  <dbid>来切换数据库。如: select 8 统一密码管理，所有库同样密码。dbsize查看当前数据库的key的数量flushdb清空当前库flushall通杀全部库</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>Redis是单线程+多路IO复用技术</p>
<p>多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）</p>
<p>串行  vs  多线程+锁（memcached） vs  单线程+多路IO复用(Redis)</p>
<p>（与Memcache三点不同: 支持多数据类型，支持持久化，单线程+多路IO复用）  </p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsMOQK0A.png" alt="img"> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/04/redis%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/3.%E5%B8%B8%E7%94%A8%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="核动力niuniu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="核动力niuniu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/04/redis%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/3.%E5%B8%B8%E7%94%A8%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class="post-title-link" itemprop="url">3.常用五大数据类型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-04 22:20:24" itemprop="dateCreated datePublished" datetime="2022-01-04T22:20:24+08:00">2022-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-05 20:26:42" itemprop="dateModified" datetime="2022-01-05T20:26:42+08:00">2022-01-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="常用五大数据类型"><a href="#常用五大数据类型" class="headerlink" title="常用五大数据类型"></a>常用五大数据类型</h4><p>哪里去获得redis常见数据类型操作命令<a target="_blank" rel="noopener" href="http://www.redis.cn/commands.html">http://www.redis.cn/commands.html</a></p>
<h5 id="Redis键-key"><a href="#Redis键-key" class="headerlink" title="Redis键(key)"></a>Redis键(key)</h5><p>**keys *** 查看当前库所有key   (匹配：keys *1)</p>
<p><strong>exists key:</strong>    判断某个key是否存在</p>
<p><strong>type key :</strong>    查看你的key是什么类型</p>
<p><strong>del key :</strong>   删除指定的key数据</p>
<p><strong>unlink key:</strong>  根据value选择非阻塞删除</p>
<p>仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作。</p>
<p><strong>expire key 10:</strong>  10秒钟：为给定的key设置过期时间</p>
<p><strong>ttl key:</strong>     查看还有多少秒过期，-1表示永不过期，-2表示已过期</p>
<p><strong>select:</strong>    命令切换数据库</p>
<p><strong>dbsize:</strong>    查看当前数据库的key的数量</p>
<p><strong>flushdb:</strong>    清空当前库</p>
<p><strong>flushall:</strong>    通杀全部库</p>
<h5 id="Redis字符串-String"><a href="#Redis字符串-String" class="headerlink" title="Redis字符串(String)"></a>Redis字符串(String)</h5><h6 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h6><p>String是Redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。</p>
<p>String类型是二进制安全的。意味着Redis的string可以包含任何数据。比如jpg图片或者序列化的对象。</p>
<p>String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M</p>
<h6 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h6><p>set  <key><value>添加键值对</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wps5ib5ec.jpg" alt="img"> </p>
<p>*NX：当数据库中key不存在时，可以将key-value添加数据库</p>
<p>*XX：当数据库中key存在时，可以将key-value添加数据库，与NX参数互斥</p>
<p>*EX：key的超时秒数</p>
<p>*PX：key的超时毫秒数，与EX互斥</p>
<p>get  <key>查询对应键值</p>
<p>append  <key><value>将给定的<value> 追加到原值的末尾</p>
<p>strlen  <key>获得值的长度</p>
<p>setnx  <key><value>只有在 key 不存在时   设置 key 的值</p>
<p>incr  <key></p>
<p>将 key 中储存的数字值增1</p>
<p>只能对数字值操作，如果为空，新增值为1</p>
<p>decr  <key></p>
<p>将 key 中储存的数字值减1</p>
<p>只能对数字值操作，如果为空，新增值为-1</p>
<p>incrby / decrby  <key>&lt;步长&gt;将 key 中储存的数字值增减。自定义步长。</p>
<p>原子性<img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpszouWWt.png" alt="img"> 所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。（1）在单线程中， 能够在单条指令中完成的操作都可以认为是”原子操作”，因为中断只能发生于指令之间。（2）在多线程中，不能被其它进程（线程）打断的操作就叫原子操作。Redis单命令的原子性主要得益于Redis的单线程。案例：java中的i++是否是原子操作？不是i=0;两个线程分别对i进行++100次,值是多少？ 2~200i=0i++i=99 i=1 i++i=2i=0  i++ i=1 i++ i=100 </p>
<blockquote>
<p><strong>mset</strong>  <key1><value1><key2><value2>  ….. </p>
<p>同时设置一个或多个 key-value对  </p>
<p><strong>mget</strong>  <key1><key2><key3> …..</p>
<p>同时获取一个或多个 value  </p>
<p><strong>msetnx</strong> <key1><value1><key2><value2>  ….. </p>
<p>同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。</p>
<p>原子性，有一个失败则都失败</p>
<p><strong>getrange</strong>  <key>&lt;起始位置&gt;&lt;结束位置&gt;</p>
<p>获得值的范围，类似java中的substring，前包，后包</p>
<p><strong>setrange</strong>  <key>&lt;起始位置&gt;<value></p>
<p>用 <value>  覆写<key>所储存的字符串值，从&lt;起始位置&gt;开始(索引从0开始)。</p>
<p><strong>setex</strong>  <key>&lt;过期时间&gt;<value></p>
<p>设置键值的同时，设置过期时间，单位秒。</p>
<p><strong>getset</strong> <key><value></p>
<p>以新换旧，设置了新值同时获得旧值。</p>
</blockquote>
<h6 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h6><p>String的数据结构为简单动态字符串(Simple Dynamic String,缩写SDS)。是可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配.</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsjwPzAS.jpg" alt="img"> </p>
<p>如图中所示，内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度len。当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。需要注意的是字符串最大长度为512M。</p>
<h5 id="Redis列表-List"><a href="#Redis列表-List" class="headerlink" title="Redis列表(List)"></a>Redis列表(List)</h5><h6 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h6><p>单键多值</p>
<p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p>
<p>它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsl87VGr.png" alt="img"> </p>
<h6 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h6><blockquote>
<p><strong>lpush/rpush</strong>  <key><value1><value2><value3> …. 从左边/右边插入一个或多个值。</p>
<p><strong>lpop/rpop</strong>  <key>从左边/右边吐出一个值。值在键在，值光键亡。</p>
<p><strong>rpoplpush</strong>  <key1><key2>从<key1>列表右边吐出一个值，插到<key2>列表左边。</p>
<p><strong>lrange</strong> <key><start><stop></p>
<p>按照索引下标获得元素(从左到右)</p>
<p><strong>lrange mylist 0 -1</strong>  0左边第一个，-1右边第一个，（0-1表示获取所有）</p>
<p><strong>lindex</strong> <key><index>按照索引下标获得元素(从左到右)</p>
<p><strong>llen</strong> <key>获得列表长度 </p>
<p><strong>linsert</strong> <key>  before <value><newvalue>在<value>的后面插入<newvalue>插入值</p>
<p><strong>lrem</strong> <key><n><value>从左边删除n个value(从左到右)</p>
<p><strong>lset</strong><key><index><value>将列表key下标为index的值替换成value</p>
</blockquote>
<h6 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h6><p>​    List的数据结构为快速链表quickList。</p>
<p>​    首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表。</p>
<p>它将所有的元素紧挨着一起存储，分配的是一块连续的内存。</p>
<p>当数据量比较多的时候才会改成quicklist。</p>
<p>因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsOLgubH.jpg" alt="img"> </p>
<p>Redis将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p>
<h5 id="Redis集合-Set"><a href="#Redis集合-Set" class="headerlink" title="Redis集合(Set)"></a>Redis集合(Set)</h5><h6 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h6><p>Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。</p>
<p>Redis的Set是string类型的无序集合。它底层其实是一个value为null的hash表，所以添加，删除，查找的复杂度都是O(1)。</p>
<p>一个算法，随着数据的增加，执行时间的长短，如果是O(1)，数据增加，查找数据的时间不变</p>
<h6 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h6><p>sadd <key><value1><value2> ….. </p>
<p>将一个或多个 member 元素加入到集合 key 中，已经存在的 member 元素将被忽略</p>
<p>smembers <key>取出该集合的所有值。</p>
<p>sismember <key><value>判断集合<key>是否为含有该<value>值，有1，没有0</p>
<p>scard<key>返回该集合的元素个数。</p>
<p>srem <key><value1><value2> …. 删除集合中的某个元素。</p>
<p>spop <key>随机从该集合中吐出一个值。</p>
<p>srandmember <key><n>随机从该集合中取出n个值。不会从集合中删除 。</p>
<p>smove <source><destination>value把集合中一个值从一个集合移动到另一个集合</p>
<p>sinter <key1><key2>返回两个集合的交集元素。</p>
<p>sunion <key1><key2>返回两个集合的并集元素。</p>
<p>sdiff <key1><key2>返回两个集合的差集元素(key1中的，不包含key2中的)</p>
<h6 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h6><p>Set数据结构是dict字典，字典是用哈希表实现的。</p>
<p>Java中HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。Redis的set结构也是一样，它的内部也使用hash结构，所有的value都指向同一个内部值。</p>
<h5 id="Redis哈希-Hash"><a href="#Redis哈希-Hash" class="headerlink" title="Redis哈希(Hash)"></a>Redis哈希(Hash)</h5><h6 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h6><p>Redis hash 是一个键值对集合。</p>
<p>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p>
<p>类似Java里面的Map&lt;String,Object&gt;</p>
<p>用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key/value结构来存储</p>
<p>主要有以下2种存储方式：</p>
<table>
<thead>
<tr>
<th><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsiR7jlN.png" alt="img"> 每次修改用户的某个属性需要，先反序列化改好后再序列化回去。开销较大。</th>
<th><img src="images/wps7ahE9x.png" alt="img"> 用户ID数据冗余</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsrnOp1m.png" alt="img"> 通过 key(用户ID) + field(属性标签) 就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题</p>
<h6 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a>常用命令</h6><blockquote>
<p><strong>hset</strong> <key><field><value>给<key>集合中的  <field>键赋值<value></p>
<p><strong>hget</strong> <key1><field>从<key1>集合<field>取出 value </p>
<p><strong>hmset</strong> <key1><field1><value1><field2><value2>… 批量设置hash的值</p>
<p><strong>hexists</strong><key1><field>查看哈希表 key 中，给定域 field 是否存在。 </p>
<p><strong>hkeys</strong> <key>列出该hash集合的所有field</p>
<p><strong>hvals</strong> <key>列出该hash集合的所有value</p>
<p><strong>hincrby</strong> <key><field><increment>为哈希表 key 中的域 field 的值加上增量 1  -1</p>
<p><strong>hsetnx</strong> <key><field><value>将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在 .</p>
</blockquote>
<h6 id="数据结构-3"><a href="#数据结构-3" class="headerlink" title="数据结构"></a>数据结构</h6><p>Hash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable。</p>
<h5 id="Redis有序集合Zset-sorted-set"><a href="#Redis有序集合Zset-sorted-set" class="headerlink" title="Redis有序集合Zset(sorted set)"></a>Redis有序集合Zset(sorted set)</h5><h6 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h6><p>Redis有序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集合。</p>
<p>不同之处是有序集合的每个成员都关联了一个评分（score）,这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复了 。</p>
<p>因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。</p>
<p>访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。</p>
<h6 id="常用命令-4"><a href="#常用命令-4" class="headerlink" title="常用命令"></a>常用命令</h6><blockquote>
<p>zadd  <key><score1><value1><score2><value2>…</p>
<p>将一个或多个 member 元素及其 score 值加入到有序集 key 当中。</p>
<p>zrange <key><start><stop>  [WITHSCORES]  </p>
<p>返回有序集 key 中，下标在<start><stop>之间的元素</p>
<p>带WITHSCORES，可以让分数一起和值返回到结果集。</p>
<p>zrangebyscore key minmax [withscores] [limit offset count]</p>
<p>返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。 </p>
<p>zrevrangebyscore key maxmin [withscores] [limit offset count]        </p>
<p>同上，改为从大到小排列。 </p>
<p>zincrby <key><increment><value>    为元素的score加上增量</p>
<p>zrem  <key><value>删除该集合下，指定值的元素 </p>
<p>zcount <key><min><max>统计该集合，分数区间内的元素个数 </p>
<p>zrank <key><value>返回该值在集合中的排名，从0开始。</p>
<p>案例：如何利用zset实现一个文章访问量的排行榜？</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wps2DNHKu.png" alt="img"> </p>
<h6 id="数据结构-4"><a href="#数据结构-4" class="headerlink" title="数据结构"></a>数据结构</h6><p>SortedSet(zset)是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构Map&lt;String, Double&gt;，可以给每一个元素value赋予一个权重score，另一方面它又类似于TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。</p>
<p>zset底层使用了两个数据结构</p>
<p>（1）hash，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。</p>
<p>（2）跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。</p>
<h6 id="跳跃表（跳表）"><a href="#跳跃表（跳表）" class="headerlink" title="跳跃表（跳表）"></a>跳跃表（跳表）</h6><p>1、简介</p>
<p>​    有序集合在生活中比较常见，例如根据成绩对学生排名，根据得分对玩家排名等。对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。Redis采用的是跳跃表。跳跃表效率堪比红黑树，实现远比红黑树简单。</p>
<p>2、实例</p>
<p>​    对比有序链表和跳跃表，从链表中查询出51</p>
<p>（1） 有序链表</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsMwAaVC.jpg" alt="img"> </p>
<p>要查找值为51的元素，需要从第一个元素开始依次查找、比较才能找到。共需要6次比较。</p>
<p>（2） 跳跃表</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wps7rEkBd.jpg" alt="img"> </p>
<p>从第2层开始，1节点比51节点小，向后比较。</p>
<p>21节点比51节点小，继续向后比较，后面就是NULL了，所以从21节点向下到第1层</p>
<p>在第1层，41节点比51节点小，继续向后，61节点比51节点大，所以从41向下</p>
<p>在第0层，51节点为要查找的节点，节点被找到，共查找4次。</p>
<p>从此可以看出跳跃表比有序链表效率要高</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/04/redis%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/4.Redis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="核动力niuniu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="核动力niuniu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/04/redis%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/4.Redis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D/" class="post-title-link" itemprop="url">4.Redis配置文件介绍</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-04 22:20:24" itemprop="dateCreated datePublished" datetime="2022-01-04T22:20:24+08:00">2022-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-05 20:25:41" itemprop="dateModified" datetime="2022-01-05T20:25:41+08:00">2022-01-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="Redis配置文件介绍"><a href="#Redis配置文件介绍" class="headerlink" title="Redis配置文件介绍"></a>Redis配置文件介绍</h4><p>自定义目录：/myredis/redis.conf</p>
<h5 id="Units单位"><a href="#Units单位" class="headerlink" title="Units单位"></a>Units单位</h5><p>配置大小单位,开头定义了一些基本的度量单位，只支持bytes，不支持bit</p>
<p>大小写不敏感</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpskauzTC.png" alt="img"> </p>
<h5 id="INCLUDES包含"><a href="#INCLUDES包含" class="headerlink" title="INCLUDES包含"></a>INCLUDES包含</h5><p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wps1A11xr.png" alt="img"> </p>
<p>类似jsp中的include，多实例的情况可以把公用的配置文件提取出来</p>
<h5 id="网络相关配置"><a href="#网络相关配置" class="headerlink" title="网络相关配置"></a>网络相关配置</h5><h6 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h6><p>默认情况bind=127.0.0.1只能接受本机的访问请求</p>
<p>不写的情况下，无限制接受任何ip地址的访问</p>
<p>生产环境肯定要写你应用服务器的地址；服务器是需要远程访问的，所以需要将其注释掉</p>
<p>如果开启了protected-mode，那么在没有设定bind ip且没有设密码的情况下，Redis只允许接受本机的响应</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsL4G8Lx.png" alt="img"> </p>
<p>保存配置，停止服务，重启启动查看进程，不再是本机访问了。</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsSjGu58.png" alt="img"> </p>
<h6 id="protected-mode"><a href="#protected-mode" class="headerlink" title="protected-mode"></a>protected-mode</h6><p>将本机访问保护模式设置no</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsVgzx6B.png" alt="img"> </p>
<h6 id="Port"><a href="#Port" class="headerlink" title="Port"></a>Port</h6><p>端口号，默认 6379</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsyAAKA9.png" alt="img"> </p>
<h6 id="tcp-backlog"><a href="#tcp-backlog" class="headerlink" title="tcp-backlog"></a>tcp-backlog</h6><p>设置tcp的backlog，backlog其实是一个连接队列，backlog队列总和=未完成三次握手队列 + 已经完成三次握手队列。</p>
<p>在高并发环境下你需要一个高backlog值来避免慢客户端连接问题。</p>
<p>注意Linux内核会将这个值减小到/proc/sys/net/core/somaxconn的值（128），所以需要确认增大/proc/sys/net/core/somaxconn和/proc/sys/net/ipv4/tcp_max_syn_backlog（128）两个值来达到想要的效果</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wps4N45mL.png" alt="img"> </p>
<h6 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h6><p>一个空闲的客户端维持多少秒会关闭，0表示关闭该功能。即永不关闭。</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wps0HFl14.png" alt="img"> </p>
<h6 id="tcp-keepalive"><a href="#tcp-keepalive" class="headerlink" title="tcp-keepalive"></a>tcp-keepalive</h6><p>对访问客户端的一种心跳检测，每个n秒检测一次。</p>
<p>单位为秒，如果设置为0，则不会进行Keepalive检测，建议设置成60 </p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsomc1nX.png" alt="img"> </p>
<h5 id="GENERAL通用"><a href="#GENERAL通用" class="headerlink" title="GENERAL通用"></a>GENERAL通用</h5><h6 id="daemonize"><a href="#daemonize" class="headerlink" title="daemonize"></a>daemonize</h6><p>是否为后台进程，设置为yes</p>
<p>守护进程，后台启动</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpszywqZp.png" alt="img"> </p>
<h6 id="pidfile"><a href="#pidfile" class="headerlink" title="pidfile"></a>pidfile</h6><p>存放pid文件的位置，每个实例会产生一个不同的pid文件</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpszbcKRZ.png" alt="img"> </p>
<h6 id="loglevel"><a href="#loglevel" class="headerlink" title="loglevel"></a>loglevel</h6><p>指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为notice</p>
<p>四个级别根据使用阶段来选择，生产环境选择notice 或者warning</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsvf4219.png" alt="img"> </p>
<h6 id="logfile"><a href="#logfile" class="headerlink" title="logfile"></a>logfile</h6><p>日志文件名称</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpstpgjdo.png" alt="img"> </p>
<h6 id="databases-16"><a href="#databases-16" class="headerlink" title="databases 16"></a>databases 16</h6><p>设定库的数量 默认16，默认数据库为0，可以使用SELECT <dbid>命令在连接上指定数据库id</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpse24tkp.png" alt="img"> </p>
<h5 id="SECURITY安全"><a href="#SECURITY安全" class="headerlink" title="SECURITY安全"></a>SECURITY安全</h5><h6 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h6><p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsfHOK4h.png" alt="img"> </p>
<p>访问密码的查看、设置和取消</p>
<p>在命令中设置密码，只是临时的。重启redis服务器，密码就还原了。</p>
<p>永久设置，需要再配置文件中进行设置。</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wps1feu1f.png" alt="img"> </p>
<h5 id="LIMITS限制"><a href="#LIMITS限制" class="headerlink" title="LIMITS限制"></a>LIMITS限制</h5><h6 id="maxclients"><a href="#maxclients" class="headerlink" title="maxclients"></a>maxclients</h6><p>Ø 设置redis同时可以与多少个客户端进行连接。</p>
<p>Ø 默认情况下为10000个客户端。</p>
<p>Ø 如果达到了此限制，redis则会拒绝新的连接请求，并且向这些连接请求方发出“max number of clients reached”以作回应。</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsEl2jUr.png" alt="img"> </p>
<h6 id="maxmemory"><a href="#maxmemory" class="headerlink" title="maxmemory"></a>maxmemory</h6><p>Ø 建议必须设置，否则，将内存占满，造成服务器宕机</p>
<p>Ø 设置redis可以使用的内存量。一旦到达内存使用上限，redis将会试图移除内部数据，移除规则可以通过maxmemory-policy来指定。</p>
<p>Ø 如果redis无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”，那么redis则会针对那些需要申请内存的指令返回错误信息，比如SET、LPUSH等。</p>
<p>Ø 但是对于无内存申请的指令，仍然会正常响应，比如GET等。如果你的redis是主redis（说明你的redis有从redis），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，才不用考虑这个因素。</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wps0taWyw.png" alt="img"> </p>
<h6 id="maxmemory-policy"><a href="#maxmemory-policy" class="headerlink" title="maxmemory-policy"></a>maxmemory-policy</h6><p>Ø volatile-lru：使用LRU算法移除key，只对设置了过期时间的键；（最近最少使用）</p>
<p>Ø allkeys-lru：在所有集合key中，使用LRU算法移除key</p>
<p>Ø volatile-random：在过期集合中移除随机的key，只对设置了过期时间的键</p>
<p>Ø allkeys-random：在所有集合key中，移除随机的key</p>
<p>Ø volatile-ttl：移除那些TTL值最小的key，即那些最近要过期的key</p>
<p>Ø noeviction：不进行移除。针对写操作，只是返回错误信息</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsDEojw6.png" alt="img"> </p>
<h6 id="maxmemory-samples"><a href="#maxmemory-samples" class="headerlink" title="maxmemory-samples"></a>maxmemory-samples</h6><p>Ø 设置样本数量，LRU算法和最小TTL算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小，redis默认会检查这么多个key并选择其中LRU的那个。</p>
<p>Ø 一般设置3到7的数字，数值越小样本越不准确，但性能消耗越小。</p>
<p><img src="https://raw.githubusercontent.com/hdlnn/hdlnn.github.io/master/images/redis/images/wpsi14yIt.png" alt="img"> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/04/redis%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/5.Redis%E7%9A%84%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="核动力niuniu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="核动力niuniu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/04/redis%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/5.Redis%E7%9A%84%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85/" class="post-title-link" itemprop="url">5.Redis的发布和订阅</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-04 22:20:24" itemprop="dateCreated datePublished" datetime="2022-01-04T22:20:24+08:00">2022-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-05 19:42:11" itemprop="dateModified" datetime="2022-01-05T19:42:11+08:00">2022-01-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="五、Redis的发布和订阅"><a href="#五、Redis的发布和订阅" class="headerlink" title="五、Redis的发布和订阅"></a>五、Redis的发布和订阅</h4><h5 id="5-1-什么是发布和订阅"><a href="#5-1-什么是发布和订阅" class="headerlink" title="5.1 什么是发布和订阅"></a>5.1 什么是发布和订阅</h5><p>Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。</p>
<p>Redis 客户端可以订阅任意数量的频道。</p>
<h5 id="5-2-Redis的发布和订阅"><a href="#5-2-Redis的发布和订阅" class="headerlink" title="5.2 Redis的发布和订阅"></a>5.2 Redis的发布和订阅</h5><p>1、客户端可以订阅频道如下图</p>
<p><img src="C:/Users/Administrator/Desktop/golang/Redis详细教程/images/wpseH2qkE.jpg" alt="img"> </p>
<p>2、当给这个频道发布消息后，消息就会发送给订阅的客户端</p>
<p><img src="C:/Users/Administrator/Desktop/golang/Redis详细教程/images/wpsTzPZ3f.jpg" alt="img"> </p>
<h5 id="5-3-发布订阅命令行实现"><a href="#5-3-发布订阅命令行实现" class="headerlink" title="5.3 发布订阅命令行实现"></a>5.3 发布订阅命令行实现</h5><p>1、 打开一个客户端订阅channel1</p>
<p>SUBSCRIBE channel1</p>
<p><img src="C:/Users/Administrator/Desktop/golang/Redis详细教程/images/wpsasL1s1.jpg" alt="img"> </p>
<p>2、打开另一个客户端，给channel1发布消息hello</p>
<p>publish channel1 hello</p>
<p><img src="C:/Users/Administrator/Desktop/golang/Redis详细教程/images/wpslLhjCY.jpg" alt="img"> </p>
<p>返回的1是订阅者数量</p>
<p>3、打开第一个客户端可以看到发送的消息</p>
<p><img src="C:/Users/Administrator/Desktop/golang/Redis详细教程/images/wpsqTEudf.jpg" alt="img"> </p>
<p>注：发布的消息没有持久化，如果在订阅的客户端收不到hello，只能收到订阅后发布的消息</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/04/redis%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/6.Redis%E6%96%B0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="核动力niuniu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="核动力niuniu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/04/redis%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/6.Redis%E6%96%B0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class="post-title-link" itemprop="url">6.Redis新数据类型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-04 22:20:24" itemprop="dateCreated datePublished" datetime="2022-01-04T22:20:24+08:00">2022-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-05 19:43:53" itemprop="dateModified" datetime="2022-01-05T19:43:53+08:00">2022-01-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="六、Redis新数据类型"><a href="#六、Redis新数据类型" class="headerlink" title="六、Redis新数据类型"></a>六、Redis新数据类型</h4><h5 id="6-1-Bitmaps"><a href="#6-1-Bitmaps" class="headerlink" title="6.1 Bitmaps"></a>6.1 Bitmaps</h5><h6 id="6-1-1-简介"><a href="#6-1-1-简介" class="headerlink" title="6.1.1 简介"></a>6.1.1 简介</h6><p>现代计算机用二进制（位） 作为信息的基础单位， 1个字节等于8位， 例如“abc”字符串是由3个字节组成， 但实际在计算机存储时将其用二进制表示， “abc”分别对应的ASCII码分别是97、 98、 99， 对应的二进制分别是01100001、 01100010和01100011，如下图</p>
<p><img src="C:/Users/Administrator/Desktop/golang/Redis详细教程/images/wpsZXmUpQ.jpg" alt="img"> </p>
<p>合理地使用操作位能够有效地提高内存使用率和开发效率。</p>
<p>​    Redis提供了Bitmaps这个“数据类型”可以实现对位的操作：</p>
<p>（1） Bitmaps本身不是一种数据类型， 实际上它就是字符串（key-value） ， 但是它可以对字符串的位进行操作。</p>
<p>（2） Bitmaps单独提供了一套命令， 所以在Redis中使用Bitmaps和使用字符串的方法不太相同。 可以把Bitmaps想象成一个以位为单位的数组， 数组的每个单元只能存储0和1， 数组的下标在Bitmaps中叫做偏移量。</p>
<p><img src="C:/Users/Administrator/Desktop/golang/Redis详细教程/images/wpsdi4EnQ.jpg" alt="img"> </p>
<h6 id="6-1-2-命令"><a href="#6-1-2-命令" class="headerlink" title="6.1.2 命令"></a>6.1.2 命令</h6><p>1、setbit</p>
<p>（1）格式</p>
<p>setbit<key><offset><value>设置Bitmaps中某个偏移量的值（0或1）</p>
<p><img src="C:/Users/Administrator/Desktop/golang/Redis详细教程/images/wpsuME1NF.jpg" alt="img"> </p>
<p>*offset:偏移量从0开始</p>
<p>（2）实例</p>
<p>每个独立用户是否访问过网站存放在Bitmaps中， 将访问的用户记做1， 没有访问的用户记做0， 用偏移量作为用户的id。</p>
<p>设置键的第offset个位的值（从0算起） ， 假设现在有20个用户，userid=1， 6， 11， 15， 19的用户对网站进行了访问， 那么当前Bitmaps初始化结果如图</p>
<p><img src="C:/Users/Administrator/Desktop/golang/Redis详细教程/images/wpsByYnuo.jpg" alt="img"> </p>
<p>unique:users:20201106代表2020-11-06这天的独立访问用户的Bitmaps</p>
<p><img src="C:/Users/Administrator/Desktop/golang/Redis详细教程/images/wpscoD2Vh.jpg" alt="img"> </p>
<p>注：</p>
<p>很多应用的用户id以一个指定数字（例如10000） 开头， 直接将用户id和Bitmaps的偏移量对应势必会造成一定的浪费， 通常的做法是每次做setbit操作时将用户id减去这个指定数字。</p>
<p>在第一次初始化Bitmaps时， 假如偏移量非常大， 那么整个初始化过程执行会比较慢， 可能会造成Redis的阻塞。</p>
<p>2、getbit</p>
<p>（1）格式</p>
<p>getbit<key><offset>获取Bitmaps中某个偏移量的值</p>
<p><img src="C:/Users/Administrator/Desktop/golang/Redis详细教程/images/wpsneUclX.jpg" alt="img"> </p>
<p>获取键的第offset位的值（从0开始算）</p>
<p>（2）实例</p>
<p>获取id=8的用户是否在2020-11-06这天访问过， 返回0说明没有访问过：</p>
<p><img src="C:/Users/Administrator/Desktop/golang/Redis详细教程/images/wpsw4n3PU.jpg" alt="img"> </p>
<p>注：因为100根本不存在，所以也是返回0</p>
<p>3、bitcount</p>
<p>统计字符串被设置为1的bit数。一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。start 和 end 参数的设置，都可以使用负数值：比如 -1 表示最后一个位，而 -2 表示倒数第二个位，start、end 是指bit组的字节的下标数，二者皆包含。</p>
<p>（1）格式</p>
<p>bitcount<key>[start end] 统计字符串从start字节到end字节比特值为1的数量</p>
<p><img src="C:/Users/Administrator/Desktop/golang/Redis详细教程/images/wpsvXGvCe.jpg" alt="img"> </p>
<p>（2）实例</p>
<p>计算2022-11-06这天的独立访问用户数量</p>
<p><img src="C:/Users/Administrator/Desktop/golang/Redis详细教程/images/wps89FZyg.jpg" alt="img"> </p>
<p>start和end代表起始和结束字节数， 下面操作计算用户id在第1个字节到第3个字节之间的独立访问用户数， 对应的用户id是11， 15， 19。</p>
<p><img src="C:/Users/Administrator/Desktop/golang/Redis详细教程/images/wpsWXoBdu.jpg" alt="img"> </p>
<p>举例： K1 【01000001 01000000  00000000 00100001】，对应【0，1，2，3】</p>
<p>bitcount K1 1 2  ： 统计下标1、2字节组中bit=1的个数，即01000000  00000000</p>
<p>–》bitcount K1 1 2 　　–》1</p>
<p>bitcount K1 1 3  ： 统计下标1、2字节组中bit=1的个数，即01000000  00000000 00100001</p>
<p>–》bitcount K1 1 3　　–》3</p>
<p>bitcount K1 0 -2  ： 统计下标0到下标倒数第2，字节组中bit=1的个数，即01000001  01000000  00000000</p>
<p>–》bitcount K1 0 -2　　–》3</p>
<p> 注意：redis的setbit设置或清除的是bit位置，而bitcount计算的是byte位置。</p>
<p>4、bitop</p>
<p>(1)格式</p>
<p>bitop and(or/not/xor) <destkey> [key…]</p>
<p><img src="C:/Users/Administrator/Desktop/golang/Redis详细教程/images/wps6Owby0.jpg" alt="img"> </p>
<p>bitop是一个复合操作， 它可以做多个Bitmaps的and（交集） 、 or（并集） 、 not（非） 、 xor（异或） 操作并将结果保存在destkey中。</p>
<p>(2)实例</p>
<p>2020-11-04 日访问网站的userid=1,2,5,9。</p>
<p>setbit unique:users:20201104 1 1</p>
<p>setbit unique:users:20201104 2 1</p>
<p>setbit unique:users:20201104 5 1</p>
<p>setbit unique:users:20201104 9 1</p>
<p>2020-11-03 日访问网站的userid=0,1,4,9。</p>
<p>setbit unique:users:20201103 0 1</p>
<p>setbit unique:users:20201103 1 1</p>
<p>setbit unique:users:20201103 4 1</p>
<p>setbit unique:users:20201103 9 1</p>
<p>计算出两天都访问过网站的用户数量</p>
<p>bitop and unique:users:and:20201104_03</p>
<p> unique:users:20201103unique:users:20201104</p>
<p><img src="C:/Users/Administrator/Desktop/golang/Redis详细教程/images/wpsefMJAU.jpg" alt="img"> </p>
<p><img src="C:/Users/Administrator/Desktop/golang/Redis详细教程/images/wpsz2jrji.jpg" alt="img"> </p>
<p>计算出任意一天都访问过网站的用户数量（例如月活跃就是类似这种） ， 可以使用or求并集</p>
<p><img src="C:/Users/Administrator/Desktop/golang/Redis详细教程/images/wpsw3pgAP.jpg" alt="img"> </p>
<h6 id="6-1-3-Bitmaps与set对比"><a href="#6-1-3-Bitmaps与set对比" class="headerlink" title="6.1.3 Bitmaps与set对比"></a>6.1.3 Bitmaps与set对比</h6><p>假设网站有1亿用户， 每天独立访问的用户有5千万， 如果每天用集合类型和Bitmaps分别存储活跃用户可以得到表</p>
<table>
<thead>
<tr>
<th>set和Bitmaps存储一天活跃用户对比</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>数据类型</td>
<td>每个用户id占用空间</td>
<td>需要存储的用户量</td>
<td>全部内存量</td>
</tr>
<tr>
<td>集合类型</td>
<td>64位</td>
<td>50000000</td>
<td>64位*50000000 = 400MB</td>
</tr>
<tr>
<td>Bitmaps</td>
<td>1位</td>
<td>100000000</td>
<td>1位*100000000 = 12.5MB</td>
</tr>
</tbody></table>
<p>很明显， 这种情况下使用Bitmaps能节省很多的内存空间， 尤其是随着时间推移节省的内存还是非常可观的</p>
<table>
<thead>
<tr>
<th>set和Bitmaps存储独立用户空间对比</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>数据类型</td>
<td>一天</td>
<td>一个月</td>
<td>一年</td>
</tr>
<tr>
<td>集合类型</td>
<td>400MB</td>
<td>12GB</td>
<td>144GB</td>
</tr>
<tr>
<td>Bitmaps</td>
<td>12.5MB</td>
<td>375MB</td>
<td>4.5GB</td>
</tr>
</tbody></table>
<p>但Bitmaps并不是万金油， 假如该网站每天的独立访问用户很少， 例如只有10万（大量的僵尸用户） ， 那么两者的对比如下表所示， 很显然， 这时候使用Bitmaps就不太合适了， 因为基本上大部分位都是0。</p>
<table>
<thead>
<tr>
<th>set和Bitmaps存储一天活跃用户对比（独立用户比较少）</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>数据类型</td>
<td>每个userid占用空间</td>
<td>需要存储的用户量</td>
<td>全部内存量</td>
</tr>
<tr>
<td>集合类型</td>
<td>64位</td>
<td>100000</td>
<td>64位*100000 = 800KB</td>
</tr>
<tr>
<td>Bitmaps</td>
<td>1位</td>
<td>100000000</td>
<td>1位*100000000 = 12.5MB</td>
</tr>
</tbody></table>
<h5 id="6-2-HyperLogLog"><a href="#6-2-HyperLogLog" class="headerlink" title="6.2 HyperLogLog"></a>6.2 HyperLogLog</h5><h6 id="6-2-1-简介"><a href="#6-2-1-简介" class="headerlink" title="6.2.1 简介"></a>6.2.1 简介</h6><p>在工作当中，我们经常会遇到与统计相关的功能需求，比如统计网站PV（PageView页面访问量）,可以使用Redis的incr、incrby轻松实现。</p>
<p>但像UV（UniqueVisitor，独立访客）、独立IP数、搜索记录数等需要去重和计数的问题如何解决？这种求集合中不重复元素个数的问题称为基数问题。</p>
<p>解决基数问题有很多种方案：</p>
<p>（1）数据存储在MySQL表中，使用distinct count计算不重复个数</p>
<p>（2）使用Redis提供的hash、set、bitmaps等数据结构来处理</p>
<p>以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。</p>
<p>能否能够降低一定的精度来平衡存储空间？Redis推出了HyperLogLog</p>
<p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p>
<p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p>
<p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p>
<p>什么是基数?</p>
<p>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</p>
<h6 id="6-2-2-命令"><a href="#6-2-2-命令" class="headerlink" title="6.2.2 命令"></a>6.2.2 命令</h6><p>1、pfadd </p>
<p>（1）格式</p>
<p>pfadd <key>&lt; element&gt; [element …]  添加指定元素到 HyperLogLog 中</p>
<p><img src="C:/Users/Administrator/Desktop/golang/Redis详细教程/images/wpsyBtJVv.jpg" alt="img"> </p>
<p>（2）实例</p>
<p><img src="C:/Users/Administrator/Desktop/golang/Redis详细教程/images/wpsIvFA0m.jpg" alt="img"> </p>
<p>​    将所有元素添加到指定HyperLogLog数据结构中。如果执行命令后HLL估计的近似基数发生变化，则返回1，否则返回0。</p>
<p>2、pfcount</p>
<p>（1）格式</p>
<p>pfcount<key> [key …] 计算HLL的近似基数，可以计算多个HLL，比如用HLL存储每天的UV，计算一周的UV可以使用7天的UV合并计算即可</p>
<p><img src="C:/Users/Administrator/Desktop/golang/Redis详细教程/images/wpsZmcy1b.jpg" alt="img"> </p>
<p>（2）实例</p>
<p><img src="C:/Users/Administrator/Desktop/golang/Redis详细教程/images/wpskhJXL9.jpg" alt="img"> </p>
<p>3、pfmerge</p>
<p>（1）格式</p>
<p>pfmerge<destkey><sourcekey> [sourcekey …]  将一个或多个HLL合并后的结果存储在另一个HLL中，比如每月活跃用户可以使用每天的活跃用户来合并计算可得</p>
<p><img src="C:/Users/Administrator/Desktop/golang/Redis详细教程/images/wpsR1ThFm.jpg" alt="img"> </p>
<p>（2）实例</p>
<p><img src="C:/Users/Administrator/Desktop/golang/Redis详细教程/images/wpsMYyOee.jpg" alt="img"> </p>
<h5 id="6-3-Geospatial"><a href="#6-3-Geospatial" class="headerlink" title="6.3 Geospatial"></a>6.3 Geospatial</h5><h6 id="6-3-1-简介"><a href="#6-3-1-简介" class="headerlink" title="6.3.1 简介"></a>6.3.1 简介</h6><p>Redis 3.2 中增加了对GEO类型的支持。GEO，Geographic，地理信息的缩写。该类型，就是元素的2维坐标，在地图上就是经纬度。redis基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作。</p>
<h6 id="6-3-2-命令"><a href="#6-3-2-命令" class="headerlink" title="6.3.2 命令"></a>6.3.2 命令</h6><p>1、geoadd</p>
<p>（1）格式</p>
<p>geoadd<key>&lt; longitude&gt;<latitude><member> [longitude latitude member…]  添加地理位置（经度，纬度，名称）</p>
<p><img src="C:/Users/Administrator/Desktop/golang/Redis详细教程/images/wpsMxAmPE.jpg" alt="img"> </p>
<p>（2）实例</p>
<p>geoadd china:city 121.47 31.23 shanghai</p>
<p>geoadd china:city 106.50 29.53 chongqing 114.05 22.52 shenzhen 116.38 39.90 beijing</p>
<p><img src="C:/Users/Administrator/Desktop/golang/Redis详细教程/images/wpsqJNuHc.jpg" alt="img"> </p>
<p>两极无法直接添加，一般会下载城市数据，直接通过 Java 程序一次性导入。</p>
<p>有效的经度从 -180 度到 180 度。有效的纬度从 -85.05112878 度到 85.05112878 度。</p>
<p>当坐标位置超出指定范围时，该命令将会返回一个错误。</p>
<p>已经添加的数据，是无法再次往里面添加的。</p>
<p>2、geopos  </p>
<p>（1）格式</p>
<p>geopos  <key><member> [member…]  获得指定地区的坐标值</p>
<p><img src="C:/Users/Administrator/Desktop/golang/Redis详细教程/images/wpsJGSoaK.jpg" alt="img"> </p>
<p>（2）实例</p>
<p><img src="C:/Users/Administrator/Desktop/golang/Redis详细教程/images/wpspgtNar.jpg" alt="img"> </p>
<p>3、geodist</p>
<p>（1）格式</p>
<p>geodist<key><member1><member2>  [m|km|ft|mi ]  获取两个位置之间的直线距离</p>
<p><img src="C:/Users/Administrator/Desktop/golang/Redis详细教程/images/wps6LOrq5.jpg" alt="img"> </p>
<p>（2）实例</p>
<p>获取两个位置之间的直线距离</p>
<p><img src="C:/Users/Administrator/Desktop/golang/Redis详细教程/images/wps8pn15k.jpg" alt="img"> </p>
<p>单位：</p>
<p>m 表示单位为米[默认值]。</p>
<p>km 表示单位为千米。</p>
<p>mi 表示单位为英里。</p>
<p>ft 表示单位为英尺。</p>
<p>如果用户没有显式地指定单位参数， 那么 GEODIST 默认使用米作为单位</p>
<p>4、georadius</p>
<p>（1）格式</p>
<p>georadius<key>&lt; longitude&gt;<latitude>radius m|km|ft|mi  以给定的经纬度为中心，找出某一半径内的元素</p>
<p><img src="C:/Users/Administrator/Desktop/golang/Redis详细教程/images/wpsTYfBml.jpg" alt="img"> </p>
<p>经度 纬度 距离 单位</p>
<p>（2）实例</p>
<p><img src="C:/Users/Administrator/Desktop/golang/Redis详细教程/images/wpsYPkw7s.jpg" alt="img"> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/04/redis%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/7.Redis_Jedis_%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="核动力niuniu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="核动力niuniu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/04/redis%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/7.Redis_Jedis_%E6%B5%8B%E8%AF%95/" class="post-title-link" itemprop="url">7.Redis_Jedis_测试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-04 22:20:24" itemprop="dateCreated datePublished" datetime="2022-01-04T22:20:24+08:00">2022-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-05 19:45:06" itemprop="dateModified" datetime="2022-01-05T19:45:06+08:00">2022-01-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="七、Redis-Jedis-测试"><a href="#七、Redis-Jedis-测试" class="headerlink" title="七、Redis_Jedis_测试"></a>七、Redis_Jedis_测试</h4><h5 id="7-1-Jedis所需要的jar包"><a href="#7-1-Jedis所需要的jar包" class="headerlink" title="7.1 Jedis所需要的jar包"></a>7.1 Jedis所需要的jar包</h5><blockquote>
<dependency> 

<p>​    <groupId>redis.clients</groupId> </p>
<p>​    <artifactId>jedis</artifactId> </p>
<p>​    <version>3.2.0</version> </p>
</dependency>
</blockquote>
<h5 id="7-2-连接Redis注意事项"><a href="#7-2-连接Redis注意事项" class="headerlink" title="7.2 连接Redis注意事项"></a>7.2 连接Redis注意事项</h5><p>禁用Linux的防火墙：Linux(CentOS7)里执行命令</p>
<p>systemctl stop/disable firewalld.service  </p>
<p>redis.conf中注释掉bind 127.0.0.1 ,然后 protected-mode no</p>
<h5 id="7-3-Jedis常用操作"><a href="#7-3-Jedis常用操作" class="headerlink" title="7.3 Jedis常用操作"></a>7.3 Jedis常用操作</h5><h6 id="7-3-1-创建动态的工程"><a href="#7-3-1-创建动态的工程" class="headerlink" title="7.3.1 创建动态的工程"></a>7.3.1 创建动态的工程</h6><h6 id="7-3-2-创建测试程序"><a href="#7-3-2-创建测试程序" class="headerlink" title="7.3.2 创建测试程序"></a>7.3.2 创建测试程序</h6><blockquote>
<p>package com.atguigu.jedis;</p>
<p>import redis.clients.jedis.Jedis;</p>
<p>public class Demo01 {public static void main(String[] args) {</p>
<p>​    Jedis jedis = new Jedis(“192.168.137.3”,6379);</p>
<p>​    String pong = jedis.ping();</p>
<p>​    System.out.println(“连接成功：”+pong);</p>
<p>​    jedis.close();</p>
<p>​    }</p>
<p>}</p>
</blockquote>
<h5 id="7-4-测试相关数据类型"><a href="#7-4-测试相关数据类型" class="headerlink" title="7.4 测试相关数据类型"></a>7.4 测试相关数据类型</h5><h6 id="7-4-1-Jedis-API-Key"><a href="#7-4-1-Jedis-API-Key" class="headerlink" title="7.4.1 Jedis-API:   Key"></a>7.4.1 Jedis-API:   Key</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jedis.set(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>);</span><br><span class="line">jedis.set(<span class="string">&quot;k2&quot;</span>, <span class="string">&quot;v2&quot;</span>);</span><br><span class="line">jedis.set(<span class="string">&quot;k3&quot;</span>, <span class="string">&quot;v3&quot;</span>);</span><br><span class="line">Set&lt;String&gt; keys = jedis.keys(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">System.out.println(keys.size());</span><br><span class="line"><span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">	System.out.println(key);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(jedis.exists(<span class="string">&quot;k1&quot;</span>));</span><br><span class="line">System.out.println(jedis.ttl(<span class="string">&quot;k1&quot;</span>));         </span><br><span class="line">System.out.println(jedis.get(<span class="string">&quot;k1&quot;</span>));</span><br></pre></td></tr></table></figure>

<h6 id="7-4-2-Jedis-API-String"><a href="#7-4-2-Jedis-API-String" class="headerlink" title="7.4.2 Jedis-API:   String"></a>7.4.2 Jedis-API:   String</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jedis.mset(<span class="string">&quot;str1&quot;</span>,<span class="string">&quot;v1&quot;</span>,<span class="string">&quot;str2&quot;</span>,<span class="string">&quot;v2&quot;</span>,<span class="string">&quot;str3&quot;</span>,<span class="string">&quot;v3&quot;</span>);</span><br><span class="line">System.out.println(jedis.mget(<span class="string">&quot;str1&quot;</span>,<span class="string">&quot;str2&quot;</span>,<span class="string">&quot;str3&quot;</span>));</span><br></pre></td></tr></table></figure>

<h6 id="7-4-3-Jedis-API-List"><a href="#7-4-3-Jedis-API-List" class="headerlink" title="7.4.3 Jedis-API:   List"></a>7.4.3 Jedis-API:   List</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = jedis.lrange(<span class="string">&quot;mylist&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (String element : list) &#123;</span><br><span class="line">System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="7-4-4-Jedis-API-set"><a href="#7-4-4-Jedis-API-set" class="headerlink" title="7.4.4 Jedis-API:   set"></a>7.4.4 Jedis-API:   set</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jedis.sadd(<span class="string">&quot;orders&quot;</span>, <span class="string">&quot;order01&quot;</span>);</span><br><span class="line">jedis.sadd(<span class="string">&quot;orders&quot;</span>, <span class="string">&quot;order02&quot;</span>);</span><br><span class="line">jedis.sadd(<span class="string">&quot;orders&quot;</span>, <span class="string">&quot;order03&quot;</span>);</span><br><span class="line">jedis.sadd(<span class="string">&quot;orders&quot;</span>, <span class="string">&quot;order04&quot;</span>);</span><br><span class="line">Set&lt;String&gt; smembers = jedis.smembers(<span class="string">&quot;orders&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String order : smembers) &#123;</span><br><span class="line">System.out.println(order);</span><br><span class="line">&#125;</span><br><span class="line">jedis.srem(<span class="string">&quot;orders&quot;</span>, <span class="string">&quot;order02&quot;</span>);</span><br></pre></td></tr></table></figure>

<h6 id="7-4-5-Jedis-API-hash"><a href="#7-4-5-Jedis-API-hash" class="headerlink" title="7.4.5 Jedis-API:   hash"></a>7.4.5 Jedis-API:   hash</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jedis.hset(<span class="string">&quot;hash1&quot;</span>,<span class="string">&quot;userName&quot;</span>,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">System.out.println(jedis.hget(<span class="string">&quot;hash1&quot;</span>,<span class="string">&quot;userName&quot;</span>));</span><br><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">map.put(<span class="string">&quot;telphone&quot;</span>,<span class="string">&quot;13810169999&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;address&quot;</span>,<span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;email&quot;</span>,<span class="string">&quot;abc@163.com&quot;</span>);</span><br><span class="line">jedis.hmset(<span class="string">&quot;hash2&quot;</span>,map);</span><br><span class="line">List&lt;String&gt; result = jedis.hmget(<span class="string">&quot;hash2&quot;</span>, <span class="string">&quot;telphone&quot;</span>,<span class="string">&quot;email&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String element : result) &#123;</span><br><span class="line">System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="7-4-6-Jedis-API-zset"><a href="#7-4-6-Jedis-API-zset" class="headerlink" title="7.4.6 Jedis-API:   zset"></a>7.4.6 Jedis-API:   zset</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jedis.zadd(<span class="string">&quot;zset01&quot;</span>, <span class="number">100d</span>, <span class="string">&quot;z3&quot;</span>);</span><br><span class="line">jedis.zadd(<span class="string">&quot;zset01&quot;</span>, <span class="number">90d</span>, <span class="string">&quot;l4&quot;</span>);</span><br><span class="line">jedis.zadd(<span class="string">&quot;zset01&quot;</span>, <span class="number">80d</span>, <span class="string">&quot;w5&quot;</span>);</span><br><span class="line">jedis.zadd(<span class="string">&quot;zset01&quot;</span>, <span class="number">70d</span>, <span class="string">&quot;z6&quot;</span>);</span><br><span class="line"> </span><br><span class="line">Set&lt;String&gt; zrange = jedis.zrange(<span class="string">&quot;zset01&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (String e : zrange) &#123;</span><br><span class="line">System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/04/redis%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/8.Redis%E4%B8%8ESpring%20Boot%E6%95%B4%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="核动力niuniu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="核动力niuniu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/04/redis%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/8.Redis%E4%B8%8ESpring%20Boot%E6%95%B4%E5%90%88/" class="post-title-link" itemprop="url">8.Redis与Spring Boot整合</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-04 22:20:24" itemprop="dateCreated datePublished" datetime="2022-01-04T22:20:24+08:00">2022-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-05 19:47:11" itemprop="dateModified" datetime="2022-01-05T19:47:11+08:00">2022-01-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="九、Redis与Spring-Boot整合"><a href="#九、Redis与Spring-Boot整合" class="headerlink" title="九、Redis与Spring Boot整合"></a>九、Redis与Spring Boot整合</h4><p>Spring Boot整合Redis非常简单，只需要按如下步骤整合即可</p>
<h5 id="9-1-整合步骤"><a href="#9-1-整合步骤" class="headerlink" title="9.1 整合步骤"></a>9.1 整合步骤</h5><p>1、 在pom.xml文件中引入redis相关依赖</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- redis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- spring2.X集成redis所需common-pool2--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、 application.properties配置redis配置</p>
 <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Redis服务器地址</span></span><br><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">192.168.140.136</span></span><br><span class="line"><span class="comment">#Redis服务器连接端口</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="comment">#Redis数据库索引（默认为0）</span></span><br><span class="line"><span class="meta">spring.redis.database</span>= <span class="string">0</span></span><br><span class="line"><span class="comment">#连接超时时间（毫秒）</span></span><br><span class="line"><span class="meta">spring.redis.timeout</span>=<span class="string">1800000</span></span><br><span class="line"><span class="comment">#连接池最大连接数（使用负值表示没有限制）</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-active</span>=<span class="string">20</span></span><br><span class="line"><span class="comment">#最大阻塞等待时间(负数表示没限制)</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-wait</span>=<span class="string">-1</span></span><br><span class="line"><span class="comment">#连接池中的最大空闲连接</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-idle</span>=<span class="string">5</span></span><br><span class="line"><span class="comment">#连接池中的最小空闲连接</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.min-idle</span>=<span class="string">0 </span></span><br></pre></td></tr></table></figure>

<p>3、 添加redis配置类</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> <span class="keyword">extends</span> <span class="title">CachingConfigurerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line"><span class="comment">//key序列化方式</span></span><br><span class="line">        template.setKeySerializer(redisSerializer);</span><br><span class="line"><span class="comment">//value序列化</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line"><span class="comment">//value hashmap序列化</span></span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line"><span class="comment">//解决查询缓存转换异常的问题</span></span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line"><span class="comment">// 配置序列化（解决乱码的问题）,过期时间600秒</span></span><br><span class="line">        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">                .entryTtl(Duration.ofSeconds(<span class="number">600</span>))</span><br><span class="line">                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))</span><br><span class="line">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))</span><br><span class="line">                .disableCachingNullValues();</span><br><span class="line">        RedisCacheManager cacheManager = RedisCacheManager.builder(factory)</span><br><span class="line">                .cacheDefaults(config)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>4、测试一下</p>
<p>RedisTestController中添加测试方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/redisTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testRedis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置值到redis</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;lucy&quot;</span>);</span><br><span class="line">        <span class="comment">//从redis获取值</span></span><br><span class="line">        String name = (String)redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/04/redis%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/9.Redis_%E4%BA%8B%E5%8A%A1_%E9%94%81%E6%9C%BA%E5%88%B6_%E7%A7%92%E6%9D%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="核动力niuniu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="核动力niuniu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/04/redis%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/9.Redis_%E4%BA%8B%E5%8A%A1_%E9%94%81%E6%9C%BA%E5%88%B6_%E7%A7%92%E6%9D%80/" class="post-title-link" itemprop="url">9.Redis事务锁机制_秒杀</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-04 22:20:24" itemprop="dateCreated datePublished" datetime="2022-01-04T22:20:24+08:00">2022-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-05 19:49:03" itemprop="dateModified" datetime="2022-01-05T19:49:03+08:00">2022-01-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="十、Redis-事务-锁机制-秒杀"><a href="#十、Redis-事务-锁机制-秒杀" class="headerlink" title="十、Redis_事务_锁机制_秒杀"></a>十、Redis_事务_锁机制_秒杀</h4><h5 id="10-1-Redis的事务定义"><a href="#10-1-Redis的事务定义" class="headerlink" title="10.1 Redis的事务定义"></a>10.1 Redis的事务定义</h5><p><img src="C:/Users/Administrator/Desktop/golang/Redis详细教程/images/wpsiVuy1s.png" alt="img"> </p>
<p>Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
<p>Redis事务的主要作用就是串联多个命令防止别的命令插队。</p>
<h5 id="10-2-Multi、Exec、discard"><a href="#10-2-Multi、Exec、discard" class="headerlink" title="10.2 Multi、Exec、discard"></a>10.2 Multi、Exec、discard</h5><p>从输入Multi命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入Exec后，Redis会将之前的命令队列中的命令依次执行。</p>
<p>组队的过程中可以通过discard来放弃组队。  </p>
<p><img src="C:/Users/Administrator/Desktop/golang/Redis详细教程/images/wpsSWbwiK.jpg" alt="img"> </p>
<p>案例：</p>
<table>
<thead>
<tr>
<th><img src="images/wpsVKLohQ.png" alt="img"> 组队成功，提交成功</th>
</tr>
</thead>
<tbody><tr>
<td><img src="images/wps7f8BVN.png" alt="img"> 组队阶段报错，提交失败</td>
</tr>
<tr>
<td><img src="images/wpsvFRZqh.png" alt="img"> 组队成功，提交有成功有失败情况</td>
</tr>
</tbody></table>
<h5 id="10-3-事务的错误处理"><a href="#10-3-事务的错误处理" class="headerlink" title="10.3 事务的错误处理"></a>10.3 事务的错误处理</h5><p>组队中某个命令出现了报告错误，执行时整个的所有队列都会被取消。</p>
<p><img src="C:/Users/Administrator/Desktop/golang/Redis详细教程/images/wpsfn9pfZ.png" alt="img"> </p>
<p>如果执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。</p>
<p><img src="C:/Users/Administrator/Desktop/golang/Redis详细教程/images/wpsXR5GDM.png" alt="img"> </p>
<h5 id="10-4-为什么要做成事务"><a href="#10-4-为什么要做成事务" class="headerlink" title="10.4 为什么要做成事务"></a>10.4 为什么要做成事务</h5><p>想想一个场景：有很多人有你的账户,同时去参加双十一抢购</p>
<h5 id="10-5-事务冲突的问题"><a href="#10-5-事务冲突的问题" class="headerlink" title="10.5 事务冲突的问题"></a>10.5 事务冲突的问题</h5><h6 id="10-5-1-例子"><a href="#10-5-1-例子" class="headerlink" title="10.5.1 例子"></a>10.5.1 例子</h6><p>一个请求想给金额减8000</p>
<p>一个请求想给金额减5000</p>
<p>一个请求想给金额减1000</p>
<p><img src="C:/Users/Administrator/Desktop/golang/Redis详细教程/images/wpsc2P7SS.png" alt="img"> </p>
<h6 id="10-5-2-悲观锁"><a href="#10-5-2-悲观锁" class="headerlink" title="10.5.2 悲观锁"></a>10.5.2 悲观锁</h6><p><img src="C:/Users/Administrator/Desktop/golang/Redis详细教程/images/wpsNHfbc7.png" alt="img"> </p>
<p><strong>悲观锁(Pessimistic Lock)：</strong>顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p>
<h6 id="10-5-3-乐观锁"><a href="#10-5-3-乐观锁" class="headerlink" title="10.5.3 乐观锁"></a>10.5.3 乐观锁</h6><p><img src="C:/Users/Administrator/Desktop/golang/Redis详细教程/images/wpszm1Tei.png" alt="img"> </p>
<p><strong>乐观锁(Optimistic Lock)：</strong>顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量。Redis就是利用这种check-and-set机制实现事务的。</p>
<h6 id="10-5-4-WATCH-key-key-…"><a href="#10-5-4-WATCH-key-key-…" class="headerlink" title="10.5.4 WATCH key [key …]"></a>10.5.4 WATCH key [key …]</h6><p>在执行multi之前，先执行watch key1 [key2],可以监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</p>
<p><img src="C:/Users/Administrator/Desktop/golang/Redis详细教程/images/wpsfxr1Ku.png" alt="img"> </p>
<h6 id="10-5-6-unwatch"><a href="#10-5-6-unwatch" class="headerlink" title="10.5.6 unwatch"></a>10.5.6 unwatch</h6><p>取消 WATCH 命令对所有 key 的监视。</p>
<p>如果在执行 WATCH 命令之后，EXEC 命令或DISCARD 命令先被执行了的话，那么就不需要再执行UNWATCH 了。</p>
<p><a target="_blank" rel="noopener" href="http://doc.redisfans.com/transaction/exec.html">http://doc.redisfans.com/transaction/exec.html</a></p>
<h5 id="10-6-Redis事务三特性"><a href="#10-6-Redis事务三特性" class="headerlink" title="10.6 Redis事务三特性"></a>10.6 Redis事务三特性</h5><p>Ø 单独的隔离操作 </p>
<p>n 事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 </p>
<p>Ø 没有隔离级别的概念 </p>
<p>n 队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行</p>
<p>Ø 不保证原子性 </p>
<p>n 事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚 </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">核动力niuniu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">30</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">核动力niuniu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
